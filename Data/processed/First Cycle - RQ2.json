[
  {
    "participant": "Participant 1",
    "data_chunk": "\"So, in some teams, it definitely does. So, again, as I said, they kind of choose how they implement it. But the QA person is always involved from planning to delivery. So as soon as the team hears about it in the team, so when the team hears about the feature, he will be involved, he will start thinking about how to test this feature from start to end. You want to make sure that all the quality aspects are taken into account. He is also responsible for maintaining the quality over the iterations. So, the first iteration may just be a bit rough, but then he takes full ownership of the quality of the output. If we expect eighty percent accuracy and he some doubts if we can reach the accuracy, if he can measure it, he or she, then we will be in discussion with them to see how we can tackle the testing process so we can deliver that quality. And if he is unsure of then quality, then have to steer our metrics so that he has confidence in the quality as well.\"\n\n\"So, while I think the developers in the team may see it as a bit of slowing them down in development. I think definitely from project management, everyone else can see the added value of the QA. And in the end, also developers do as well because they know the target to hit. They know how to hit it, they have someone there that has the expertise to help them reach the quality assurance. It may sometimes give some...I'm looking for the English word...not fighting, but these are disagreements. But that's fine. That happens in every team, happens in every development.\"",
    "code": [
      "Early engagement of QA"
    ]
  },
  {
    "participant": "Participant 1",
    "data_chunk": "\"So, the main thing, as I said, is that we have testers and we have multiple environments. So, we have a test environment, acceptance environment, canary environment. So, the very close customers can get access to the features early. And then we have a production environment and all of these environments have rigorous testing. There's also unit tests and there is someone from QA on board of every team, having feature requests from the start to the end. There is a pretty rigorous checklist, if you will, of everything that a feature has to go through before it goes to production. Is there anything specifically that you want more information about?\"",
    "code": [
      "Software Testing",
      "Unit testing",
      "Early engagement of QA",
      "Checklist"
    ]
  },
  {
    "participant": "Participant 1",
    "data_chunk": "\"Yes. I’ll explain. The transparency of the Scrum process makes team members accountable. Because, everyone on the team has visibility on the deliverables and can scrutinize its quality. If you fail to deliver the quality expectations then you will look bad or the team will think you slowing them down.\"",
    "code": [
      "Transparency in Scrum",
      "Quality review",
      "Software quality"
    ]
  },
  {
    "participant": "Participant 1",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 10",
    "data_chunk": "\"I mean when people collaborate in Scrum, they share their knowledge more efficiently. They review each other’s code and learn from each other how to write better code and what is the best option to code a particular problem. This knowledge exchange help producing the best code the team is capable off.\"",
    "code": [
      "Peer to peer learning",
      "Knowledge sharing",
      "Better code"
    ]
  },
  {
    "participant": "Participant 10",
    "data_chunk": "\"If implemented correctly, yes, sure. Absolutely, because what Scrum did, because in a sense, agile doesn't speak to quality directly. I mean, it's just sort of implied that you should provide things with high quality. You shouldn't put out crappy results, although sometimes you have to compromise. But still, it's the implied sense that you're providing something that is good. And in this sort of hectic environment, you don't always inject the classical QA that takes like two months to test the whole thing. So, you have all these techniques appear with continuous integration, with automated testing, with scripted testing, where you write a script that actually clicks things through. You have the developers testing themselves. You have code reviews where developers review the code of each other and that helps with education and that all produces better quality.\"",
    "code": [
      "Collaboration"
    ]
  },
  {
    "participant": "Participant 10",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 11",
    "data_chunk": "\"First thing is documentation, the acceptance criteria has to be in place. It has to be written and in the right format. Do not miss any of the use cases even if anything is remotely related to it, just jot it down, every use case is important. So, there is something called acceptance criteria and there is something called as definition of done. Acceptance criteria has to be clear enough for the QA team to understand what the process of this is, and this has to be followed. What is the critical path that needs to be followed in order to make this functionality as definition of done? Only when all the acceptance criteria on that you can make sure that the stories actually done. Even if one acceptance criteria is missing or you know, there's some okay, there could be some cosmetic changes or some cosmetic defects that are related to the features, but those are low level, whether it’s' important or not important. Like the button color is white and even the background is white. That is obviously going to be a high priority issue because you do not see the button anymore. But if it's slight red, not dark red, but a lighter shade of red. So, it's a low priority issue because the functionality still working fine, and the user is still able to access it.\"",
    "code": [
      "Acceptance criteria"
    ]
  },
  {
    "participant": "Participant 11",
    "data_chunk": "\"I literally saw a lot of automation test cases running on and actually it was a hundred percent error free. So, I would say that that was a great amazing achievement for all of us, going from eight hundred errors to zero errors. And even the development team over the period of time, they learned a lot from being agile and just because I think they were not mature when they started but they eventually at the end of the product they saw there were literally no errors. There could be some cosmetic errors also, but in the end when we saw this many drops in the number of errors and errors we are facing we actually thought this is a great idea going forward and make the system that robust and it was a big thing. It was a big achievement and when we started, we had so many errors, so that was major reason for me going into Agile because one should know you can't just take up things unnecessarily and start working on it. It's a waste of time for the client, for all the developers as well.\"",
    "code": [
      "Automated testing"
    ]
  },
  {
    "participant": "Participant 11",
    "data_chunk": "\"I would say so, a hundred percent because at the end when the features are done, they have to go back to the customer, and they have to be checked. So, checked as in the customer actually runs it through a UAT testing, that is user acceptance. User acceptance when they perform it or even when the demo sessions go on, so technically the developers when they develop something, they go back to the customer and they have to demo it saying are they okay with this? The initial stage itself, the client can actually see how the product looks like and they actually can rectify the things that they really want to, so it becomes out of every initial stage. So, I'm actually going forward in the future as well because this continues on transparency that is maintained between the developers and the clients.\"",
    "code": [
      "User acceptance testing"
    ]
  },
  {
    "participant": "Participant 11",
    "data_chunk": "\"It does help. For example, I talked about the demos; during these session we show to the customer the features and we get feedback. This feedback helps us to improve the quality and reduce bugs. That’s with the customer. Within the team, our work is transparent. In daily bases I know what my peers are doing and I can comment on its quality. Another example, is when a developer push a pull request. Other developers can see it and review the code quality. The review helps improving the code quality.\"",
    "code": [
      "Transparency",
      "Quality review",
      "Improved quality"
    ]
  },
  {
    "participant": "Participant 11",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 12",
    "data_chunk": "\"And the company made it clear that no matter the consequences, obviously, except the illegal reasons, but no matter the consequences, people wouldn't be sanctioned for discussing their opinions, sharing their concerns and so forth. So, it was a very psychologically safe environment that people were encouraged and are really happy to work with their colleagues despite the distances between the offices.\"",
    "code": [
      "Psychological safety"
    ]
  },
  {
    "participant": "Participant 12",
    "data_chunk": "\"It does [psychological safety helps software quality]! What I have observed is developers and QAs for example take initiative more and invest on the success of the product including its quality. For example, developers put more effort and time on writing better code. The QAs become invested and care about the quality of the software, even the relationship between developers and QAs improves. They communicate better and share information faster to understand bugs. The team becomes more efficient at assuring quality. I saw improvement on the quality.\"",
    "code": [
      "Investing on quality",
      "Improved quality"
    ]
  },
  {
    "participant": "Participant 12",
    "data_chunk": "\"It improves the understanding of the requirements, what the team will develop and test. So, we see less bugs, because developers know what to develop and QAs know what to test and how to test it. So, quality doesn't happen just at the end of the work that the developers perform and once the coding is done. Quality should be embedded at every single stage as early as the user stories are created, as early as the acceptance criteria is discussed and then put on paper, or as early as if you are using a Gherkin model, or as early as the statements are written.\"",
    "code": [
      "Understanding the requirements",
      "Improved quality"
    ]
  },
  {
    "participant": "Participant 12",
    "data_chunk": "\"Well, quality is something that should be thought at early level within the development lifecycle. But at the granular level, you want to encourage conversations as early as the backlog refinement. You remember this term I used earlier?\"",
    "code": [
      "Collaboration"
    ]
  },
  {
    "participant": "Participant 12",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 13",
    "data_chunk": "\"I mean more engaged and vested in the success of the product and its quality. They care more about quality. They write better code, they test more, motivated to meet customer needs, etc.\"",
    "code": [
      "Caring about quality"
    ]
  },
  {
    "participant": "Participant 13",
    "data_chunk": "\"Okay, so when you do your ... generally, Agile caters for technical excellence like having to have good code, having both manual and automation, but mostly automation. So, if you are doing the technical excellence practices of Agile, not just Scrum, then you can have very good quality code and with good quality code, it must release. Also, something that's very part of the Agile culture is to have continuous delivery and continuous integration, at least, if it's not continuous delivery. If you're doing all of those things while coding each iteration not [inaudible], but let's say at some point when you have a releasable product when you have an MVP, you'll be able to release it very quickly.\"",
    "code": [
      "Automated testing",
      "Software testing",
      "Continuous integration"
    ]
  },
  {
    "participant": "Participant 13",
    "data_chunk": "\"People become comfortable in their own skin. What I observed is developers, QAs and everybody else become fully present, they want the product to succeed. A successful product in software development means at least free of bugs and meets the business expectations.\"",
    "code": [
      "Software quality"
    ]
  },
  {
    "participant": "Participant 13",
    "data_chunk": "\"Yeah it is. When getting it done correctly. Probably the retrospective starts, at least for me, when I started to work as a Scrum master, I really liked those meetings because you can always experiment with the different format. You can do something different. It can be fun. However, they are very challenging because you should have actionable items not just being so not just complaining so it doesn't become a blame game. People should feel safe and they should feel comfortable in these retrospectives. So, I'm really putting some time to choose the right format depending on the situation. So, we have the discussion set in place and then we're taking the actions, normally the team. But I'm also taking some actions from the retrospective myself if they're on more kind of a higher level, if the team needs some kind of training, if they have some problems with the environment that they cannot fix themselves.\"",
    "code": [
      "Psychological safety",
      "Speaking up"
    ]
  },
  {
    "participant": "Participant 13",
    "data_chunk": "\"Yes. It improves the quality. The things that improve the quality clearly, good code, you should have coding standards. They are set by the developers. They should do code reviews and they should feel kind of responsible for not merging back all the time. Generally, if you think that something a team member had written is bad, you shouldn't have it in your code base. Then after the code, it's like good tests, useful tests because you can test everything, you can automate everything but most of the time you don't even need it. So, it should be done wisely. I used to have a strategy, what to automate, what to test manually, what to run what. And then if you release often there are bugs always so you will have some things to fix for sure. If you're lucky, they will be kind of minor. If you had missed something, it might be some incident that's a bit more impactful. But however, if you can release quickly, you can release quickly and release it again.\"",
    "code": [
      "Coding standards",
      "Code review"
    ]
  },
  {
    "participant": "Participant 13",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 14",
    "data_chunk": "\"In the Waterfall world, what project manager does, he go around collect the requirement. He gets the quality requirement details, project calls to budgeting risk. So, all of these things a project manager was giving direction to the team. He first collects the requirement and comes up with a plan and give direction to the team on what is needed. But for Scrum, what happens, even the inexperienced developer or QA or whoever it is that when we say development team, it consists of all those skills required to develop the product. So, everyone has a say. The team as a group, we are thinking how we can deliver the value and we are constantly checking with the customer about what we are building, \"are you okay with that?\" So that continuous inspection and adaption of change, that is what delivers value to the customer. Did I answer your question?\"",
    "code": [
      "Inspection and adaptation"
    ]
  },
  {
    "participant": "Participant 14",
    "data_chunk": "\"Yeah, definitely. In Scrum if you see the product backlog. The product backlog should follow the deep prioritization technique that is derived appropriately, and merge and change. The team backlog should be able to do conjure more of the feedback and we should be able to customize our backlog accordingly to deliver better quality value for the customer. So yeah, that feedback is what makes the biggest difference in Agile compared to the Waterfall project. Inspection and the continuous adaption improves quality. And also, transparency. That is the important bit. We are really transparent in our meetings. As part of a Scrum master that is what I am doing. I provide all the data, make it transparent to the team. The backlog would be transparent to the team. At the end of each sprint, I provide a sprint report to the team to make everything transparent to show this is how we are getting on, are we on target. So, this continuous feedback helps us to build a better product.\"",
    "code": [
      "Improved quality"
    ]
  },
  {
    "participant": "Participant 14",
    "data_chunk": "\"Yeah. If you see all the Scrum ceremonies, it is built around that. Especially the main focus would be a Scrum master, we provide that to the team. The team performance data to reflect back how are we going, what process changes we can implement to build a product. And also, each meeting, even the standup, we are checking against the sprint goal. How are we progressing against the goal? What changes can we make because as we build the product, we know some challenges, we come across some blockers. And even daily we are reflecting back and seeing what small changes we can make in order to achieve the sprint goal, which we agreed upfront. So, it applies for all the things, all the meetings, even in the sprint review, we are seeing we are delivering what the customer expected. Are we meeting the customer's expectation or product owner's expectation?  We are seeing the actual product, reviewing the product, and making constant changes. So, all of these agile ceremonies, I would say is around the inspect and adapt concept.\"",
    "code": [
      "Feedback"
    ]
  },
  {
    "participant": "Participant 14",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 15",
    "data_chunk": "\"Okay, so firstly, the sprint planning meeting right. So, during the sprint planning meeting, each and every user story. So, they user stories are already there in the black block. In our set up, what I always advise the team, is that they should go through the user stories applied to the sprint planning meeting so that they know for sure what are the questions they have for the product owner. So that helps. So now, a set of the team has gone through the user stories. They know what is there in the background. They join the meeting. So how it helps is, whatever question that he has, the product owner answers it during the sprint planning meeting itself. So, the sprint planning meeting is the start of the sprint. So, if we have any doubt or query, that is answered at the very beginning rather than bringing up questions towards the end. That gives the team of the entire duration of the sprint, to work on something, rather than if it was the question was asked later on. This collaboration with the PO helps better understanding of the user stories. Then the team knows what to develop and test. What I have experiences, it a good collaboration with a knowledgeable PO reduces defects. We receive feedback on ongoing bases and we rectify quickly.\"",
    "code": [
      "Collaboration",
      "Feedback",
      "Fewer bugs",
      "Understanding the requirements"
    ]
  },
  {
    "participant": "Participant 15",
    "data_chunk": "\"So that is another thing for the quality part. Lastly, which is very helpful is the review meeting. The review meeting ensures that whatever is developed is actually what the customer wanted. End of the sprint, we are showing whatever we achieved in that particular sprint to the customer. So, in case the customer wants some changes, he can always request but then that request also goes in as a user story in the next sprint. So, the team could incorporate that change and then the same iteration will follow, and then again, the same thing would be displayed to the customer during the meeting at the end of the other sprint. So, this are the some of the ways that doing this ritual helps in actually having a quality software. \"",
    "code": [
      "Feedback"
    ]
  },
  {
    "participant": "Participant 15",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 16",
    "data_chunk": "\"So, what happened is the tester has got complete knowledge. The other thing I would like to call out is around the skill set of the testers. That is very important. Usually again this is something which people love to keep it under the carpet is that testers are usually having lower skill sets than a developer. So, what happens is, for example, if you're a tester and I'm a developer and I have developed something but if you don't have the knowledge of how to test it, you cannot challenge me back. And, if you can't challenge me back, you won't have a robust project. So, the tester is at the mercy of the developers saying, OK, you do it this way, it will pass. That is one of the challenges where we miss on creating a robust product because the testers skill set are not seriously looked upon as we look at a developer's skill set. That is a gap we need to bridge. When we mention testing in iterations, again all boils down to the tester's knowledge. If a tester is knowledgeable of the business requirements, he can participate in the product increment planning or this sprint planning saying that these bits can be developed. Let's divide the project into three iterations, A B and C. So, A can be tested after the first sprint. B can be tested after the second sprint and C can be tested after the third sprint. The testers knowledge of the requirements helps reducing the bugs significantly and make the testing much more efficient.\"",
    "code": [
      "Knowledgeable of the business requirements",
      "Fewer bugs"
    ]
  },
  {
    "participant": "Participant 16",
    "data_chunk": "\"They will start delivering value very soon and they will start organizing the teams' behavior in such a way that, giving the example of the merger and acquisition project, is that I was successfully able to break down the big project into small iterations, have the testing team  get involved with the business analyst from day one so that the testers get a complete knowledge of what is the kind of product that the organization is looking for. So, it was more around transparency, everyone has got the entire team including the developers, the waterfall teams. Again, the problem is the structure. There is a developer, there is a tech lead, there is application lead, there is design team, this is not beneficial to the product. Again, in this hierarchy like the developer doesn't get view of the requirements and stuff like that. So, there were many challenges but the best way for it to be done was that have the tester involved with the requirements from day one.\"",
    "code": [
      "Early engagement of QAs"
    ]
  },
  {
    "participant": "Participant 16",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 17",
    "data_chunk": "\"And then after all this, of course, we have some tests in place, some automatic tests that we also develop. So, since we work with data, it's a bit complicated. I don't know how technical I should or could go here, but we just have some tests running on production, on the data to see if it's expected. So, for example, an easy example is, if every day we sell one thousand items, and if one day, one of our tests picks up one million items, something's wrong with it. So that's on part where we have some tests. These tests are all in production, these final ones I'm talking about now. But here also, I think the QA for the quality or quality side of things. Maybe I'm just rambling a bit now.\"",
    "code": [
      "Automated Testing",
      "Software Testing"
    ]
  },
  {
    "participant": "Participant 17",
    "data_chunk": "\"For me personally, I don't agree with it because I want the developer who picks up the story to also have a bit of a clear mind. So, there's no predefined, preconceived ideas on how to develop it. So, to also give them a bit of freedom. But then, of course, when he starts developing it, he can always ask the peers to help or even sometimes some things are more complex, then that person requests a meeting and we all go into a room and we just brainstorm together for one hour. But in the refinements, there's always a touch point where we all talk about it and we kind of have an idea on how it will work best to get this new feature into what we have right now. And then personally, in my team, we have a lot of, I would say, probably a big project that's been going for five, six years, which means a lot of it code. So, for every new thing that we add, it has to be carefully thought of on how best to do it because some things are easier. In general, all of the features have to be carefully thought on how to implement this. When developers choose their own story to work on, they feel ownership and duty to deliver better work and its quality is far superior. This is from experience...\n\nI totally agree. I think it's good to empower developers without feeling fear from the consequences. And also, not only empower the people to change behavior and to voice their opinions. So, this I can also sidestep a bit here. This is also a bit what the scrum master has to do. Because some people will talk less, and some others will talk more. But in this setup, once again, it's nice to have a scrum master that can read the room and I think that person over there has a question that maybe he's not raising it right now. So, it's also good to have people that's has more of the agile mentality, to bring the voice out of people. So, I totally agree. It really brings people closer to what they are developing in the end. In the end, if you're just going to your workplace, not now because we work from home, but you just do your new features and then you turn it off and you really don't know the impact it has then after a while, I think it gets a bit boring. And you just don't care that much about if it will be a good one or a bad one.\n\"",
    "code": [
      "Psychological safety",
      "Ownership of quality",
      "Improved quality"
    ]
  },
  {
    "participant": "Participant 17",
    "data_chunk": "\"I think on what comes to mind, but I think it also depends on the thoroughness of tests, also depends on the product that you are doing on the software or on the business that you are in. I would say that is if you want to develop, for example health. If it's something related to health, to hospitals that cannot fail at all. Then I would say that you will have to have more tests and more people testing everything than what we have in my team, for example. Because the things that we do, if they fail a bit, I would say that maybe when things go to production, I would say, ninety-five percent of them go well. And we'll have like five percent of the features that have some bugs. For our case, in my opinion, is totally acceptable because it brings us advantages like the speeds and developing things faster and having faster feedback from stakeholders. I think it overwrites the five percent of defects that we find over time. In Scrum, we have this frequent inspection by the business users; the feedback we get early on the process reduces bugs. But of course, this is in our business and in our team. I believe that if it was something crucial that really cannot fail. I believe that we will need to have more and more deep testing than what can we do now.\"",
    "code": [
      "Inspection and adaptation",
      "Feedback",
      "Fewer bugs"
    ]
  },
  {
    "participant": "Participant 17",
    "data_chunk": "\"So yeah, we do have a lot...just off the top of my head, I would say that at least maybe like half of the tickets on code review, they go back. They find something, maybe not half, but like twenty or thirty percent. And it is good. For me, as a scrum master, that's also good. Because it also proves that code reviews are not just clicking a button. And I also think that when you have a dedicated QA, you will be more specialized in bringing all the places where it can go wrong. It will be better for sure. Like I said, it could be better but once again, I think there needs to be a balance between the speed of delivery and the quality of the code. Not that the code quality will be much worse, but I think it will be acceptable considering the speed you are bringing.\"",
    "code": [
      "Code review"
    ]
  },
  {
    "participant": "Participant 17",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 18",
    "data_chunk": "\"Exactly! That’s a good summary.\"",
    "code": [
      "Knowledgeable of the business requirements"
    ]
  },
  {
    "participant": "Participant 18",
    "data_chunk": "\"I think it is, yes.\"",
    "code": [
      "Software quality"
    ]
  },
  {
    "participant": "Participant 18",
    "data_chunk": "\"If the code review is passed, the code goes to the testing. QA implements testing phase. First of all, they test manually. Then if everything is okay, if the feature works completely, they write automation test cases. If the feature is broken, it doesn't complete requirements from the written task, we return it to developers for the feature to be improved. For example, a button is working on five pages, but on the sixth page, the button doesn't work. It throws some server error. We have in that period, we can have a ping pong effect between developers and the QA. Especially developers who doesn't want to listen and doesn't want to listen to the QA. So, they're not reading tasks properly, there's no detail during the implementation of that task so there can be a ping pong effect. It's not so often, but it can be observed. If the task is okay and it's tested properly, it can be delivered. It can be delivered together with other tests from the sprint or it can be delivered as a single module. It depends on how the team implemented the delivery, then tasks are delivered. The product owner informs the customer and the customer is observing what we prepared for them. And if they're satisfied, great. If they're not, they're complaining to the product owner on what can be improved. And in the next sprint to be are improving what we did in the previous sprint.\"",
    "code": [
      "Code review",
      "Software testing",
      "Automated tests"
    ]
  },
  {
    "participant": "Participant 18",
    "data_chunk": "\"We know what to test we assume less which help us identify real bugs and less bugs.\"",
    "code": [
      "Fewer bugs"
    ]
  },
  {
    "participant": "Participant 18",
    "data_chunk": "\"Well, as I mentioned, when you deliver small pieces of code, an example, two or three features in a sprint. You're able to control and to follow all the bugs and to correct most of them. But for example, if you have a time frame of a year, and after a year you have to test something, it's more likely that you will pass into the production more bugs and more defects because it was quite a large period of time. It's a bunch of code. Then after fixing the bugs, you can cause new bugs and it's really a mess. When you have a small period of two or three weeks, you have a small piece of code which is testable, which is iterative, it allows you to produce better code quality.\"",
    "code": [
      "Frequent testing",
      "Iterative development",
      "Inspection and Adaptation"
    ]
  },
  {
    "participant": "Participant 18",
    "data_chunk": "\"Yes, yes, it is. In my company, it is. We have sprint planning, sprint grooming. In sprint grooming, there is only the team leader of the team and product owner and they're discussing big features which will be developed in the sprint. The next day we have sprint planning where we have the product owner, QA, designer team as an independent component. And they're estimating tasks, which the product owner defined previously. And the developers are estimating their work and QA estimating the QA work. And after that, we assume its full estimation of one task.\"",
    "code": [
      "Early engagement of QAs"
    ]
  },
  {
    "participant": "Participant 18",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 19",
    "data_chunk": "\"I think the most important thing, which I noted, was that since we were giving a demo to the client on a regular basis, they were aware of the functionality. Actually, they were seeing the end product. So, when the project was released, there were no surprises for them. They were already aware of the product. They were happy to accept it. Then the project went into the third phase of maintenance. They're actually using. It was not a surprise for them.\"\n\n\"Because giving a demo many times, because they were seeing the end product, they used to give comments if it’s not in line with their functionality or not in line with what they imagined. So, we used to go back and check the requirement, what was the reason why we didn't develop according to that vision. So, if it was a mistake, then we used to develop it, if not, then we used to go for a change request. This iterative inspection process allowed us to correct, adjust and at the end deliver functionality that meet the client’s needs.\"",
    "code": [
      "Inspection and adaptation",
      "Feedback",
      "Meets the business needs"
    ]
  },
  {
    "participant": "Participant 19",
    "data_chunk": "\"It does! We become better knowledgeable about the requirements and we participate in the user stories. This collaboration helps us to know what to test and we catch more bugs. To be honest, I loved working in Agile because you have your own identity. People know that you know stuff then they appreciate you. So, it's instant gratification, I would say. Because the more you work, the more you are appreciated. And because of more communication, developers also appreciate you and you also appreciate the developers. And because I have been appreciated by the developers, that I work with scenarios which are rare. It's really quick, the turnaround time is short.\"",
    "code": [
      "Knowledgeable of the business requirements",
      "Fewer bugs"
    ]
  },
  {
    "participant": "Participant 19",
    "data_chunk": "\"So, what I know from working in waterfall is that when the requirement was given to us, that is very less chances of discussing it and improving over it. When BA used to come with wireframes and discussing the requirements, we use to ask her questions. And many times, I've seen that asking questions actually altered the requirement to be more user friendly or to be more in line with the market requirement, which is not the case with waterfall. Because during waterfall, the requirement was written almost six, seven months before and person who has actually written the requirement was probably not present. So, there was no live discussion as such.\"",
    "code": [
      "Collaboration"
    ]
  },
  {
    "participant": "Participant 19",
    "data_chunk": "\"So, what happened was for all the use cases we used to test, we would give a demo to the client , so it was a continuous process. I was part of a team that followed Scrum to the line. So, the use cases are bound by a time box that is called sprints. The only difference was that I don't think that tweaked scrum and actual Scrum with Sprints which help the product quality. When development and testing is time-boxed, we have certain control over the quality of the way we work and  the quality of the product. So, following sprints, makes us more competent and makes us know more about our shortcomings and good things also.\"",
    "code": [
      "Inspection and adaptation",
      "Software quality"
    ]
  },
  {
    "participant": "Participant 19",
    "data_chunk": "\"Yes! Basically, we test more often, we get frequent feedback from the PO and we rectify much quicker and bugs do not slip to production. And even if they do we can still correct in the next Sprint. Overall the quality is always better. More importantly, we learn quicker about the actual business needs, we make less and less assumptions.\"",
    "code": [
      "Frequent testing",
      "Knowledgeable of the business requirements"
    ]
  },
  {
    "participant": "Participant 19",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 2",
    "data_chunk": "\"Collaboration helps better quality by facilitating intensive exchange of information and feedback which help resolve and minimize bugs. Not only bugs, but I’ve seen developers helping each other’s and learning from each other’s how to write better code and resolve complex issues. Sometimes they are design questions or how to make a piece of code simpler and maintainable.\"",
    "code": [
      "Collaboration",
      "Peer to peer learning",
      "Knowledge sharing",
      "Better quality"
    ]
  },
  {
    "participant": "Participant 2",
    "data_chunk": "\"For me, the QA is a constant thing because everyone needs to ensure quality. QA starts from the beginning. I know that developers may say that they are not QA people or anything like that but QA starts by the developer doing a good job. And if we talk about specific testing, good practice is for the developer to do unit testing on every function he or she develops. That function must be tested. Then once that feature and user story is developed and tested, the developers release it to a testing environment. And there the QA team picks up the new features deployed to the environment, and they perform testing. Sometimes manual, sometimes automated. If it works, they deploy it to staging. And in staging, sometimes the stakeholders they test in staging. Sometimes there is another additional step, which is UAT, user acceptance testing. That is a different environment.\"",
    "code": [
      "Unit testing",
      "User acceptance testing"
    ]
  },
  {
    "participant": "Participant 2",
    "data_chunk": "\"Of course, it does. Knowing that other people are expecting you to deliver, you may be more committed. If you give someone something to do, OK, go to your desk, nobody is going to ask you for this, no other knows who is going to need it, that person is not going to do a good job. If he or she feels they don't have a job at all, but after you know that other people need what you implement, they are going to use what you are doing, that motivates you. It fires you up. You know that you are working on something for you, you are working for other people. You are accountable to the rest of the team. See, the culture is that everyone is accountable for everyone. The rest of the team is accountable for you. And you hold accountability for other people too. That, to me is great. And if you can keep the size of the teams to ten people maximum, that is even better. They larger the team, the less sense of closeness you have.\"",
    "code": [
      "Accountability"
    ]
  },
  {
    "participant": "Participant 2",
    "data_chunk": "\"Well, a number of things. Improving quality in the development practices. In that way, you need to allow the development team to come up with a good development practices. It was just me that one would come up with that when I was on the technical side. Now, the development teams I work with, they do that. They need to have good development practices. I'm not talking about the detail guides on how to name the variables, because creating excessive documentation may delay the team. But I'm talking about general guidelines so that’s something that I need to do. You can use software that detects automatically and evaluates the quality of your code.\"",
    "code": [
      "Quality assurance practices"
    ]
  },
  {
    "participant": "Participant 2",
    "data_chunk": "\"Well, because if you don't communicate, if you don't collaborate, then what happens is that they develop things that are wrong. When they find out it's wrong, they're not working well. They start blaming each other, ah but you didn't tell me, but you could've asked. And they are getting these into resentment arguments. So, it is great that once a day you force them to collaborate.\"",
    "code": [
      "Collaboration"
    ]
  },
  {
    "participant": "Participant 2",
    "data_chunk": "\"Yes, it does. I’ll explain more and use the developers as example. When the culture is that everyone is accountable for everyone, developers feel accountable to meet the team’s expectations on quality. In other words, delivering substandard code quality is letting the team down. Accountability boosts the individual motivation to meets expectations including the quality of the code in the case of developers. I have seen it in practice, developers write better code when they feel accountable.\"",
    "code": [
      "Accountability",
      "Support the collective effort to achieve quality",
      "Code quality"
    ]
  },
  {
    "participant": "Participant 2",
    "data_chunk": "\"You are right. I absolutely left that out. When I say the team gathers to talk about the story, an agile or scrum team must typically put down these details. It means developers, QA, the PO, scrum master, everyone. So you are right. QA must be involved from the start.\"",
    "code": [
      "Early engagement of QA"
    ]
  },
  {
    "participant": "Participant 2",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 20",
    "data_chunk": "\"Definitely. OK. For one thing, Researcher, what I really believe, and I want to share that with you. Agile is very, you know, modules based delivery model. Like in Waterfall, you understand, there is always five, six deliveries in test planning and then test preparation and then test execution. There is a lot of things we exchange with clients. Client as the stakeholders or you can say product owners. But in terms of Agile, I really feel the number of deliverables are very low. Let's say sprint planning, so once you understand the user requirements or user stories from the product owner, with their priorities, you discuss within your team and understand which priorities can be met within the same time frame. Or your sprint planning should be, OK, so I don't know this is very internal, I'm just sharing, and it might help you. So, it is very iterative and modular. It helps a lot to inspect the features and correct any errors very quickly, because as I said the scope is small and the iterations are fast.\"",
    "code": [
      "Inspection and adaptation"
    ]
  },
  {
    "participant": "Participant 20",
    "data_chunk": "\"I may not have explain it clearly! It’s the iterative and ongoing inspections. The client inspect frequently and their feedback help us to correct and understand the requirements better. The iterative part is that we fix defects quickly if they pop up after releases. So, the quality at the end of the sprint is better at least less bugs.\"",
    "code": [
      "Fewer bugs",
      "Feedback"
    ]
  },
  {
    "participant": "Participant 20",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 21",
    "data_chunk": "\"And in that way, when we have those in those peering sessions, I get to see and read more about like their working environment. I probably get a bit closer to the code and they will learn a bit of my testers, intuition, magic. And it starts rubbing off on them. And then separately we probably organize sessions. We keep saying, let's do our regression testing. But in fact, people don't understand the regression testing. So probably do a session and explain, hey, this is regression, and this is what we do. And when you ask me for a full regression, it's actually not a full regression. What we do is we just check the most risky areas. And I guess another layer of quality in Agile, and there's not just one way to test, and there's not just one way to do things for all of the stories. Depending on the context, depending on the type of work it is, we'll have a different strategy and we have different levels of testing. So, you'll have your unit testing, you have your integration test and you have all your different tests.\"",
    "code": [
      "Regression testing",
      "Unit testing"
    ]
  },
  {
    "participant": "Participant 21",
    "data_chunk": "\"And then what I've been doing lately, I try work with the PMs very closely and with the devs, and everyone in the team, but with the PMs specifically to try and break down big stories into smaller ones that can be more testable, like easier software to deliver and that's how we deliver value quicker to our customers. I did the acceptance criteria to the stories to make sure that we all, as team, we understand what needs to be done for that story. And how do we achieve completeness. And which has the Done criteria, I guess. With the developers, I worked with them after they've done their coding work. We'll sit down together, and we'll do some further testing and check some of the acceptance criteria. We would probably agree on what level of testing needs to happen for story. And then after they're developed, I'll talk to them and say, OK, so what have you tested about that. And they say, OK, I tested this and tested that. So, if you tested that, we don't need to do that right now. So, let's go and focus on things that you haven't tested for some other risks that I came up with or based on my domain knowledge of the product or my own experience.\"",
    "code": [
      "Acceptance criteria",
      "Software testing"
    ]
  },
  {
    "participant": "Participant 21",
    "data_chunk": "\"Like, personally, I think, yes. In my first project, the only project I worked in was Waterfall. It was like I was sitting at my desk every day right, writing test cases, or some other day I would just execute test cases or someone else did, then it was just like boring work. But then in the Agile cross-functional team setting, probably two days are not the same. And you're working on what the team needs at the moment. So you're testing whatever they're building at the moment or you're helping to plan the user story to make sure that once a developer builds something, there are no assumptions, and there's no misunderstanding between what the devs understood from my user story or what the tester understands from the user story. The whole development team understands the requirements better. And what ends up being delivered at the end.\"",
    "code": [
      "Collaboration",
      "Knowledgeable of the business requirements"
    ]
  },
  {
    "participant": "Participant 21",
    "data_chunk": "\"Yeah, I think so, because as I said before, we make less assumptions. The developers produce features that are better aligned with the business needs and the testers know what to test. This knowledge and close communication help reduce bugs. Collaboration makes a difference in software development, you're not just interacting with testers every day, which is not a bad thing, but you're interacting with other disciplines and then you get a more holistic understanding of how software work, what the business want and how software helps the users. And you learn from other professionals like in a tester and develop relationship, there's always an exchange of skills and knowledge because when you work together with the engineer you might bring attention to issues that maybe a developer didn't think about. And if you are working with a developer, maybe he has a troubleshooting tool or something to that aids in testing, which if you didn't collaborate with the dev, you probably wouldn't know there was a different way of doing things or a faster way of doing things.\"",
    "code": [
      "Peer to peer learning",
      "Fewer bugs"
    ]
  },
  {
    "participant": "Participant 21",
    "data_chunk": "\"Yeah. I would say so. I’m not sure whether this is agile or the organization I work for. But we are encouraged to speak our mind without fear. This helps a lot. For example, when I see work with lower quality than I expect or the whole team expect, then I’m not afraid to say it. If you were with a team, like if you work in a team that's engaged and people like care about what they're doing, then there's that psychological safety where sometimes you can make mistakes or other people make mistakes and know that that's okay. That's definitely a better feeling. Not only mentally, but I’ve seen people attitudes changes. They care about the quality of the product and this helps for better quality.\"",
    "code": [
      "Psychological safety",
      "Better quality",
      "Speaking up",
      "Caring about quality"
    ]
  },
  {
    "participant": "Participant 21",
    "data_chunk": "\"Yes. So, I mean, code review is pretty much mandatory, it needs to happen by devs, it's kind of non-negotiable. And then, I guess things like monitoring the logging and alerting, testing in production, doing feature [inaudible], canary releases, dogfooding, all those are things that help accelerate the speed of delivery as well increase the confidence and increase the risk appetite as well for teams, because if they know that if something goes wrong, then we're going to get an alert and they can turn off the feature flag and it's back to business as usual. Then they'll probably take more risks and then we'll monitor our production use closely. And then instead of doing exhaustive testing before production, we put the software in the hands of our customers and then we learn from their use. If they are doing a three week regression cycle, to do it for regression, we just put it in production, let it burn, see if we get any errors. If we do, we'll roll back or turn off the feature flag, and if things go great, we say they rip.\"",
    "code": [
      "Code review"
    ]
  },
  {
    "participant": "Participant 21",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 22",
    "data_chunk": "\"On the current project, it has a lot of specifications, meaning technical specifications from the organization who needs the product. So just today, I was actually discussing about user manual, about a team who had a request and actually forgot about it, or just, I don't know, it was missed somehow. At the end, the point was bringing the initial discussions of the project like the quality code, meaning sonar and so on and so on. So, except using tools to improve your quality of the code, except using maybe the four I principle to improve the process of reviewing the code. I mean, like a PR has to be reviewed by two people. Something like that. This is a process to put it in place to assure the quality of the code and of the technical solution. This is what actually we do from this point of view of the code.\"",
    "code": [
      "Code review"
    ]
  },
  {
    "participant": "Participant 22",
    "data_chunk": "\"Then, of course, you have to have a good architecture and to follow the best practices and to select the proper technologies, because we even had issues with that. Somebody selected the technology and when it was asked, please bring me a solution because I have this and this problem, but I'm not an expert. So, how did you choose the technologies, fix it, you proposed it. This is about the quality of the code and the whole architecture and so on. A lot of problems are coming from this and a lot of bugs are actually introduced due to this and also a lack of knowledge due to the business flow. A lot of the developers are just developing but when I'm asking them, hey, what's behind this, what's the logic and what's the business flow that I should see in the front end or so on. I don't know. I just did what's written in the story so that. \"",
    "code": [
      "Best practices"
    ]
  },
  {
    "participant": "Participant 22",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 23",
    "data_chunk": "\"Definitely. It makes a huge impact on overall quality because like I said, for instance, you deliver something and during the ceremony, you display your product to the product owner. However, to make things even better, to make it much higher quality, you could develop an automation suite rather than doing your manual tests, doing the regression testing over and over. It might take like twenty hours of time to do the manual testing. At a result, the quality might be the same but there is always a chance you might miss a scenario or two so that's part of the regression manual testing. But the benefit of automation testing when you develop an automation tool, like if there's a code change, if there is a functionality change, you just go back to the script and just update those scripts only. All it takes it just instead of running twenty hours of manual testing effort, automation it takes like a couple of hours. You should be able to achieve the quality much quicker. And you can identify the defects in a timely manner. And you should be able to report to the development team and that gives them enough time in the sprint to fix the issues and get back to you. So that way, you can still re-execute the automation suite and then it’s good to go. So, that's one way to achieve higher quality. Develop an automation test suite so that way it will save you some time and also time to find missing critical functionalities. \"",
    "code": [
      "Software testing",
      "Automated testing",
      "Regression testing"
    ]
  },
  {
    "participant": "Participant 23",
    "data_chunk": "\"It makes me feel very confident about the product. I'll tell you why. Because it starts from the PI planning, all the way to creating and accepting user stories. Because I know what direction I'm heading to. I know what's my user story, I know what my focus is. I know what the deadline is. So, I have to work everything in, and I feel actually happy because I have constant interactions with my tech lead and product owner. So, any time I have any questions regarding the product, or any technical specifications, I could directly engage my technical lead unlike in Waterfall methodology, you start in a very, like you don't interact with your technical lead, to be honest. You just start working on your requirements and start developing the test plans and test cases. But in Agile, that's the benefit because you get to know more about the product, you get to demo the product to the product owner, the rest of the team and also a wider audience. You know you have a tight timeline to deliver the product, you always have something to deliver at the end of the sprint. So that is what being a QA, I like about it.\"",
    "code": [
      "Early engagement of QAs"
    ]
  },
  {
    "participant": "Participant 23",
    "data_chunk": "\"It should be like to develop the better quality, like being in an Agile environment, because you get constant feedback about the product does not mean you're going in the wrong direction. You may be going on the right path however sometimes the product owner like prior to the sprint, he may not be clear to you how the product works and how the feature works. In the example I gave to your earlier, the One Time Pin when you login with your username and password, all the requirements we got from the product owner was just develop this web page just with your phone number, you give an option to the user as either phone number or their e-mail address. That's part of the requirement and we developed it and tested it, and everything works as expected. As part of the sprint review, review meeting,  we went through the sprint session, the product owner came back and said, after we presented the demo, yes this page looks good but as part of the security measures, we don't like to display the whole characters or whole phone number to the user, so we should mask it with asterisks. \n\n\nBut this wasn't clearly defined as part of the product and even he didn't know because when he was given the requirements by the product manager, that's all he got. But when we provided the demo, that's how we got the feedback from the product owner. Like we should have more features that are part of the security measures. So, it wasn't clearly defined. In Agile you don't have the product clearly defined. You start working on it as soon as you get it, the user story. This help us to meet the PO needs with less defects because of the ongoing feedback.\"",
    "code": [
      "Inspection and adaptation",
      "Fewer bugs",
      "Feedback"
    ]
  },
  {
    "participant": "Participant 23",
    "data_chunk": "\"The more I know about the business needs, the better I test and the better I test then less bugs.\"",
    "code": [
      "Fewer bugs",
      "Knowledgeable of the business requirements"
    ]
  },
  {
    "participant": "Participant 23",
    "data_chunk": "\"Yes. So, make sure we have exit criteria before we close the user story. Because at the beginning of the sprint, we accept the user story and start working on it and provide the number of hours. At the end of the user story, we have some guidelines. In order to close this user story, what are the guidelines, what are the criteria needed to close the user story. My criteria as a quality assurance in the Agile environment, make sure the user story meets all the criteria including the business team's criteria and the product owner's criteria. All the use cases have been met, all the test cases have been executed, there are no critical, high, or medium defects. It is fine to have a low priority defect for instance the look and feel of the application. \"",
    "code": [
      "Exit creteria"
    ]
  },
  {
    "participant": "Participant 23",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 24",
    "data_chunk": "\"So, the conclusion, we do work in a very dynamic environment and everything is done in less time compared to the waterfall model where we used to spend two or three days in requirements analysis then two weeks in development and one week in testing. Compared to that everything happens together in a fully-integrated Agile team, which I've part right now. And there is slight risk involved because requirements are sometimes not defined properly because of lack of time, so we have a little bit risk.\"",
    "code": [
      "Collaboration"
    ]
  },
  {
    "participant": "Participant 24",
    "data_chunk": "\"Yes, very much. With a fully integrated Agile team, we learn from each other’s about for example how to resolve defects. We learn from the PO what the accurate requirements. This shared knowledge help us develop better product.\"",
    "code": [
      "Peer to peer learning",
      "Knowledgeable of the business requirements",
      "Better product"
    ]
  },
  {
    "participant": "Participant 24",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 25",
    "data_chunk": "\"Sorry. I'm getting back to that. So, here how we are following the quality or what are the quality processes we are doing here. I will explain you. So, once the sprint grooming was completed. We have a plan that certain items from backlog may be assigned to the sprint. Okay, so we will have a planning where the story points has been assigned to the stories. Now, we have to assign the story that we are addressing, to the individual all from members will be available in the planning call. They will pick the stories for development for the code ready. We follow all the processes in development, testing, code review, test case preparation, test case review, test execution. So, for all these activities we will give hours to complete this. Okay, this hours will be given by the respective development team members, since they are all having knowledge about the story or product whatever. So, there can be an impediment we will face in the time of doing development. It can be delayed. \"",
    "code": [
      "Software testing",
      "Code review"
    ]
  },
  {
    "participant": "Participant 25",
    "data_chunk": "\"Yes. Yes, yes, but this is [inaudible] is the valuable one where they are involving the QA at the earliest stage. Since why I'm telling see that the phase that they started doing the development, they need to have an analysis or developer needs to analyze even tester also can analyze. Here one thing we previously do the test case preparation and we will have it with us, and we will wait for the development to be completed and come for testing. And then we will execute the test case and we find the bug and then give it to them. So, where here the cost of defects fixing will be more. Okay, what now we are doing since we are engaging them from an early stage, we ask that developer and tester to work together to understand the functionality clearly so that midway, the testing team can give the test cases to the development team on what to do to cover the unit testing. So, due to this process, we are avoiding the maximum number of defects which we are getting in the testing phase. So, that is why we now we feel that that is an alien because sometimes functionally across the module, across the application, testers have a very good knowledge of the requirements. So, this will help the development team members to check the dependent models with regression testing which cause of this fix, maybe it will impact in some other case.\"",
    "code": [
      "Collaboration",
      "Knowledgeable of the business requirements",
      "Fewer bugs"
    ]
  },
  {
    "participant": "Participant 25",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 26",
    "data_chunk": "\"From the QA perspective, in a practical situation, day to day, we're just testing and cross verifying it with expectations in the task. So, the quality comes from the planning and the description. What is expected from the developer to do? I have to work with the stakeholders inside the company to stop doing one sentence descriptions on what you want us to do. Because the QA slogan, I told them to enforce it always, that few hours of planning equals few weeks of development and save. So, the first rule of the QA, as a task owner in our company, was the responsibility to understand, fully understand what really needs to be done. Not even beyond the description. I told them, drill their heads, call them all the time. Message them, overcommunicate. So, the beginning of making a task is more important than just dealing with it in the middle. Because in the beginning, you can eliminate those return moving to the Return column.\"",
    "code": [
      "Software testing"
    ]
  },
  {
    "participant": "Participant 26",
    "data_chunk": "\"Good question! Because it does and people under estimate its effect. The most important thing is the relationships improve immensely. They do not see each other’s adversaries but collaborators. When they collaborate they share their knowledge better. They share their understanding of the requirements and why a bug is a bug and how to resolve it. If you make your testers feel not valued, you will have poorly tested software, because the developers, they don't test so much. Because they love coding and you need to understand the nature of your team and then incorporate Scrum, not incorporate Scrum and force them to change their nature.\"",
    "code": [
      "Knowledge sharing",
      "Software quality"
    ]
  },
  {
    "participant": "Participant 26",
    "data_chunk": "\"So that is the first step of quality assurance. If we know that we are prepared and we understand what we need to do, then we can follow up with the development process. And the development process was, in our quality assurance was, first of all, not only allowing the testers to have a staging environment to verify if the task was finished properly, but also to have his unique branch and you need the subdomain for just this only one task isolated. So, we're heavily using regression testing before having, let's say, end of sprint situation to deliver the tasks. So, our focus, in my opinion, the biggest source of good quality software is the regression process. If the task itself isolated is fulfilling the needs and then if you really know that it's fulfilling, then as a whole, you see if it doesn't work, then it's creating a conflict between other functionalities of the software. But if you straight away, like many companies do, deliver to the staging environmental, tell the testers and automation engineers to test it, then they don't know if it's only the task or as a whole, there's a conflict. So, they waste time. So, you need to have this pre stage step in the delivery process.\"",
    "code": [
      "Regression testing"
    ]
  },
  {
    "participant": "Participant 26",
    "data_chunk": "\"So, I brought in the importance for them, but also created this kind of collaboration between the QA and the developer that the QA is always available to the developer and the product owner, it's not. So, they create this kind of a trust. If I develop it the way you say it, and if I do it exactly like that, it means I didn't do the mistake. You take responsibility for the interpretation of the task. And this empowered them like they didn't become managers, but they became like they managed the responsibility. And that was Sebastian and Jacob. And they were really thrilled after a few months of trying it out. Because I always struggle with the QA's motivation because we really need them. They are really crucial, and they don't feel like it. They tend to be excluded, unappreciated, or even underpaid.\"",
    "code": [
      "Collaboration"
    ]
  },
  {
    "participant": "Participant 26",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 27",
    "data_chunk": "\"OK. You're building Lego and you look at the instructions and you build it the first time. And then your kid comes around and breaks it and cries is, and says hey, you know what I want? I want it fixed back up. It's faster to put it together the second time. You know that old saying. To me, that's what Scrum does. Scrum helps you refine the software so that all the little bugs, all the little quirks, all the little kinks get worked out in the process. And, through many eyes looking at it and many people taking ownership and responsibility for it, I think that this is a very good set of checks and balances. It doesn't rely on one person, the project manager, to keep track of everything. It allows the whole team, it has everybody to take responsibility and have accountability for the overall project.\"\n\n\"I believe they do. I believe that team members, once they have a kind of buy-in. So, here's the deal, is that the project management, let's say we're not in the Agile environment, in project management, you dictate to the developer what the hours are. You're saying, hey, you have this many hours, and this is what you have to work with, this particular piece of software. And it kind of becomes a little bit of a dictatorship in the way that it is run. And with Scrum, I feel like that the team member during the sprint planning, the team member actually says, hey, that's going to cost this main story points. You know what story points are, right?\"",
    "code": [
      "Psychological safety",
      "Invest on quality",
      "Support the collective effort to achieve quality"
    ]
  },
  {
    "participant": "Participant 27",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 28",
    "data_chunk": "\"Because we collaborate with a lot of other teams. For us it's mobilization or bug fixing. We need to release our platform more often.\"",
    "code": [
      "Collaboration"
    ]
  },
  {
    "participant": "Participant 28",
    "data_chunk": "\"I follow my issues that I developed in the software and I stay in touch with the testers. I ensure to test the problems before we go into production. And, we have a lot of meetings. So, speaking with each other is really helpful.\"",
    "code": [
      "Software testing"
    ]
  },
  {
    "participant": "Participant 28",
    "data_chunk": "\"Scrum helps us to work very well together. The product we developing is complex, so knowledge and how to deal with complex problem is important to us. We always discuss how to go about things and we come up with the most efficient solutions. You know, we develop automation software for pharmaceutical manufacturing; it can be complex. When we talk and learn from each other’s we come up with better design and better code.\"",
    "code": [
      "Peer to peer learning",
      "Knowledge sharing",
      "Better code"
    ]
  },
  {
    "participant": "Participant 28",
    "data_chunk": "\"Yes, because every moment we know what the teammates are doing. And we see what products they are working and what they need to do. And this can help to organize your work and you need to do something, you remember once your teammates have something similar, maybe two months ago and you can ask how to approach the problem and so on. People can comment on my work anytime and criticize my coding and design decisions. This helps the quality of my work and I learned extensively from my teammates feedback. As I said I’m the youngest and less experienced in the team.\"",
    "code": [
      "Transparency",
      "Feedback",
      "Better quality"
    ]
  },
  {
    "participant": "Participant 28",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 29",
    "data_chunk": "\"From experience, yes. When the QAs and the developers collaborate closely, we see less bugs.\"",
    "code": [
      "Less bugs"
    ]
  },
  {
    "participant": "Participant 29",
    "data_chunk": "\"OK. So definitely during development cycle, we used to test all the acceptance criteria along with the regression. Now that you can use story, now at the end when all the stories has been completed. In the beginning of the next sprint Researcher, we used to take one task into the maintenance to test all the stories together, which we was delivered in the previous. And tested together with a very early start in the new sprint because QA has less work. They're under-utilized so make sure they are utilized completely. You should test two stories only. We do integration test and once all this sprint is completed, we used to keep one week of buffer before going to production where we test all the stories together in a staging environment and then sign off.\"",
    "code": [
      "Software testion",
      "Acceptance criteria",
      "Integration testing",
      "Regression testing"
    ]
  },
  {
    "participant": "Participant 29",
    "data_chunk": "\"Ok, I’ll summarize. Scrum makes the team more efficient. Efficient team produces better product and software quality. Most importantly we are empowered; this facilitate sharing information with better transparency. Bugs are found and communicated without fear or feeling of guilt or fear. The team operate better, because our relationships are strong. We feel very close to each other’s and minimum power over us. We invest more effort on quality and we produce code with less bugs.\"",
    "code": [
      "Psychological safety",
      "Fewer bugs",
      "Invest on quality"
    ]
  },
  {
    "participant": "Participant 29",
    "data_chunk": "\"Yes. QAs is definitely engaged from the beginning because when the grooming meeting are being set up, QA is part of it. So, QA should have the understanding of the user story like every other team member. So, everyone should have to be on the same page as part of user story understanding. So, when it comes to testing, I won't waste a lot of time to understand the user story. When the user story pulled into the current sprint backlog, the current stream, the developer who starts coding and QA will start creating the test case. Once the story is out, the QA need to execute his test cases and make sure the user story acceptance criteria are being coded. Both the developers and QAs are in sync, they understand what to deliver and how to test it.\"",
    "code": [
      "Early engagement of QAs",
      "Understanding of the business requirements"
    ]
  },
  {
    "participant": "Participant 29",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 3",
    "data_chunk": "\"Don’t get me wrong! It does. Yeah. For example, people collaborate more; so, everyone understands the requirements better to achieve a software with fewer bugs. As I told you before, people feel safe and empowered to invest more effort on quality. Agile also very compatible with practice like pair programming.\"",
    "code": [
      "Collaboration",
      "Understanding the requirement",
      "Fewer bugs"
    ]
  },
  {
    "participant": "Participant 3",
    "data_chunk": "\"For us what happened, the software quality because it was shipping every day, we had a lot of automated tests. So, the automated tests was one way of just like, it was stress testing. So, before we shipped anything, so shipping every day doesn't mean that if you submit your code today, it would definitely get shipped today because your code may run into errors. So, for the first test is all the automated tests. It took us quite long, one or two weeks to set up all the automated tests and test security, to test the UI, to test all the things. So that was the first phase. The second phase was human testing. We had a team in China that would do stress testing. So, they would just go clicking on the buttons and testing everything. That was the second phase and they would file bugs. The third phase was actually a bug bash. Where one hour before we ship any feature, all the engineers who worked on it, the product manager, the designer and the engineering manager who is leading the team, would all come together in a room for one hour and everyone was just testing it and finding bugs. So, we had three phases. First is automated testing. The second was a remote team in China. The third thing was the people who actually brought the product. I don't know if that's such a good idea because we're biased by the people who actually built the product were testing it. So, we had two rounds of human intervention before shipping it.\"",
    "code": [
      "Automated testing",
      "Security testing",
      "UI testing",
      "User acceptance testing"
    ]
  },
  {
    "participant": "Participant 3",
    "data_chunk": "\"I don't think they are correlated because you can be empowered but if you're not a really efficient worker, you will use empowerment at the wrong time to do something. But I think just because in my team or the nature of those who Microsoft has hired, people are generally a Type A. They are very driven, very ambitious and very efficient. So, I feel like in the past they were efficient, but because it was not transparent, they were not empowered. So, they didn't want to do a really good job. Or people see [name of organization] not really as a place to contribute, but to sit back and do the least work, to get the most amount of money. Big companies. And generally, I would say is most of [name of organization]. That has been my experience in parts of [name of organization], that I worked in different divisions and I felt that. But I felt like in this group because they meet us, the product owners, every one of the product, it generally created a better sense of empowerment and empowerment given to talented people, and transparency and everything, I think it can be a very powerful force to the potential of every employee working for the team and organization.\"",
    "code": [
      "Empowerment"
    ]
  },
  {
    "participant": "Participant 3",
    "data_chunk": "\"Of course it [psychological safety] does! For example, developers can challenge each other on the quality of the code part of the code review without the fear of peer reprisal. A developer can say to another developer, there is a better way to code this without fear. Another example, I saw a whole team taking initiatives to deliver better quality. When there is no fear, developers innovate and invest time to deliver better quality.\"",
    "code": [
      "Speaking up",
      "Investing on quality",
      "Better quality"
    ]
  },
  {
    "participant": "Participant 3",
    "data_chunk": "\"So, I think that kind of culture really got people to be more collaborative. They got people to be less afraid of failure. Because if you had a lot of psychological fear of failure, then you can't get true good ideas out there. But if you're like, oh, the only way to ship successful products is if you throw it out there and then you learn from your failures. So, this means shipping and getting it into the hands of the customer and actually seeing how they use it.\"",
    "code": [
      "Psychological safety"
    ]
  },
  {
    "participant": "Participant 3",
    "data_chunk": "\"Some engineers, the most senior ones, they didn't like it. So sometimes they didn't do it. But generally, we encourage pair programming. I think the Agile environment helps in that way because everyone was more transparent. Everyone was less protective over their code. We also had one product backlog, one repository, everyone could see anyone's code or change anyone's code. That also helped with quality. Let's say I code something, and my code has mistakes or whatever, anyone was empowered to comment on my code and help on my code and submit approve request to better it. Of course, the person who wrote it would have to approve it but generally it would be approved.\"",
    "code": [
      "Transparency"
    ]
  },
  {
    "participant": "Participant 3",
    "data_chunk": "\"Sure! The code or other artifacts are not hidden or a secret. The opposite, any team member is welcome to scrutinize their quality and as I explained they feel empowered to do so without fear. The result is improved quality. In Scrum, this happens in the daily stand-up. People inform the whole team of their achievements and in retrospectives and reviews; we talk about our weaknesses and we point out areas of improvements.\"",
    "code": [
      "Quality review",
      "Improved quality"
    ]
  },
  {
    "participant": "Participant 3",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 3",
    "data_chunk": "People become more committed and invest more effort in producing quality work including better code, better design and overall the software quality.",
    "code": [
      "Investing on quality",
      "Better software quality"
    ]
  },
  {
    "participant": "Participant 3",
    "data_chunk": "Yes, I wasn't doing it [code review], but the engineering manager did. Before [product name], well now it's called Azure DevOps, but basically [products names] is a [organization name] product, and everyone had to review each person's code. The person who submitted approve request cannot approve their own code. You need two other approvals from different ... and they have to be managers to approve. And then the person who merged the approve request cannot be either of those people. So, it's SOC. We had to do some GDPR thing, so we had things to follow.",
    "code": [
      "Code review"
    ]
  },
  {
    "participant": "Participant 30",
    "data_chunk": "\"But it's my responsibility to come up with some new software tools. I come and say, I'm thinking we should like test driven development. When you're doing unit and feature. I went and did some research on it. And I was like, now, I'm thinking this is where we need to go so that you can save the time for testing. So now I come, we sit down, and we discuss, and he's called Alvin. I said, Alvin, we need to talk about ABC, I'm thinking we should implement it like this. He asks me why should we implement it? Is it useful? We'll discuss, yes, because I think ABC, then now we implemented. So that's for the principles. For the tools, we use linters. So, like every product has, like, for example, front end tools, we have an ESLint and a Prettier file that is set by the software lead. So, when the software lead says, this is what this product can look like. So now, two spaces, arrows of the parentheses, everything that they feel is important, and we tend to use, instead of using our own predefined steps, we tend to use the global presets. Like personally, we prefer the Airbnb standard, like from JavaScript. So, when you declare an ESLint, you set up the file. Then you say everyone was working on this project, you have to, by default, the system substring, lots of errors, if you don't use the linting tools that are provided. And so that's one of the ways we use to keep quality. We use linters that are set for the whole project globally. So that even if you create a file in a file in a folder and a folder in a folder, the same rules apply. Actually, they've been the most efficient, especially when it comes to front end work. That's been a very efficient tool for us. Because before some people like two spaces in the HTML, some people like four. That linter makes sure that everything, nothing compiled is a mess, those problems are solved.\"",
    "code": [
      "Unit testing",
      "Code review",
      "Software testing",
      "Static Analysis Tool"
    ]
  },
  {
    "participant": "Participant 30",
    "data_chunk": "\"I'll give two answers. One, it's very subjective, I'm showcasing my code and it works very well on Friday. Very nice to have. His code is nice, don't worry. Like that feeling of yeah, because it's a public forum. So, when you're going to the code and there's no problem and everything is fine. It's good. You feel good. And there's no problem. And two, the benefit of Scrum, this is when I was working for other teams, and I was already a junior developer, is when things don't work as well, I don't feel like oh, no, it was my fault. Everything went bad because I made a mistake. It's like, because we're all in this environment of review. That review doesn't mean why did you get this wrong? It means I can see you didn't think about this. Next time let's do this. I don't feel attacked for being wrong. If that makes any sense. I feel less inclined to feel attacked. So, I'm more productive, because I can just focus on doing what I can to be more productive and better quality.\n\n....\n\n\nDepends on the organization. I'm happy enough that the organizations that I deal with are my organizations we I've worked, the Scrum is a bit informal. It's not suit and tie. If you get it wrong, you feel like you've lost a job. It's more of Okay, so what did you do? So, if an environment is welcoming and understanding that people make mistakes sometimes then you feel confident going to Scrum.\"",
    "code": [
      "Psychological safety",
      "Transparency",
      "Motivation for quality",
      "Better quality"
    ]
  },
  {
    "participant": "Participant 30",
    "data_chunk": "\"Scrum streamlines that process and says you do this because this is important, or this is important that everyone focuses their attention based on some things. Based on a highest standard that's being set. And once they do their work to the highest standard that checks it again. For me, that's the differences Scrum brings to quality.\"",
    "code": [
      "Better quality"
    ]
  },
  {
    "participant": "Participant 30",
    "data_chunk": "\"Scrum, for me, speaking, first of all, with an individual before, because I've worked for many different companies, and I've worked as a freelancer, not just as a company, as a company lead, as a freelancer. So, I've been on boarded with many other projects, some that use Scrum, some that didn't, some I just do work, we'll pay you when we done. What I find, the truth is, if you do Scrum well enough, if you really implement it, and are very careful, and anyone is dedicated to it, the need for a project manager diminishes. Because what happens is, you already know exactly what you're supposed to do. You know when you're supposed to get it done, you know how it's supposed to be done. And you know, exactly by Friday, and to have finished this, it needs to work like this, this and this, the client is waiting for it because for the client, it means this and this and this. So, what Scrum does, is it gives you, instead of you as a developer having to focus on every single thing. And the problem with having every single thing in mind is that the quality drops, with Scrum you just have to think of this week, I have to do this. So, you can focus your attention. And when you focus your attention on that smaller subset of things you can do, the quality always goes up. That's something I can do. I can almost...it always goes up. Whenever you give the developers smaller bits of frequent work, the quality goes up, because the developer can focus on today, this table has to work. I will make this table work very well, as opposed to giving them a plethora of thirty things. In their thinking of because even when they're doing one thing, item one or thirty, they can't even take time to focus on it. Because they're thinking, I have to do to thirty-three, or thirty-four, or thirty-five, or forty. It makes the quality go up. And it gives the programmer less to juggle.\"",
    "code": [
      "Iterative development",
      "Focus on quality",
      "Modularity of tasks"
    ]
  },
  {
    "participant": "Participant 30",
    "data_chunk": "\"So, for that, one, is how we make sure that it gets exactly what the client wants is when the client is giving us the project. And the client says, I want an ecommerce store, or I want let's see whatever system to measure my agricultural outputs with hardware devices, because sometimes we do hardware devices. They have to give us, it's not an option, the client has to give us a written document outlining all the user scenarios. So that when we are building, we are going back to this to this particular item and checking. The client says they wanted to be able to send reports within ten seconds, does it do that. So that's the fastest way that we can make sure on the externals. The second part is we meet with the client regularly, every three weeks, depending on the client. Some want it longer, some want it shorter, we meet. We show them this what we have so far. Let's have a discussion to see, the client goes to the system. Now this is between the project lead and the software lead. The developers are not, they can, we tend to invite them so we can see the process. And sometimes after some questions that we may not have the best answers and that's usually when it's why you did this. And the client, in those meetings, we are taking notes, anything that they say, I'm not liking this, this isn't what I asked for, or did you also add this, or I was thinking of a scenario where I conduct our business this might happen. So, during those conversations, we are taking notes and recording them so that when we go now for the next set of Scrums, we're making sure that the client was satisfied with what was already done, and what wasn't, we are implementing it as we go along.\"",
    "code": [
      "User acceptance testing"
    ]
  },
  {
    "participant": "Participant 30",
    "data_chunk": "\"So, they say okay, they're watching. Then my partner because we in the meeting together. At that time, he was the software lead. I was a product lead. He goes, just remove the clients we see. Just delete all the guardians, we want to see how that works. Then the developer deleted the guardians. When they deleted, the system crashed. The form that was not okay, not the whole system, the form that was collecting that data it crashed. So, the developers like, oh, I haven't considered a situation where, yeah, so you have to consider that because the developer is thinking from a developer perspective, not really business. So, they were like, yeah, you have to consider some of the schools we'll go to won't have parents with registered phone, so now, go back and make sure that this code throws an error that looks like this when the school doesn't have any guardians. So, if we didn't do that meeting, you just let the developer, if you let them check themselves that yes, this worked, yes. Because from the perspective, it can send, it can send notifications if you just let them check themselves without that quality review. Without that, wait, let's test this thing, make sure it works completely, then roll it out, that would have gone to production, that was there. So, for us Scrum, just such things happen during Scrum, when you're having the Scrum meeting, reviewing the work, such things happen, because the different perspectives and developments have occurred in those meetings.\"",
    "code": [
      "Inspection and adaptation",
      "Bugs resolution"
    ]
  },
  {
    "participant": "Participant 30",
    "data_chunk": "\"So, they're like, oh, I didn't know that I didn't because I locked it. I didn't consider like, the hard coded apart, or like you didn't make it as dynamic as possible, because they didn't know how this is actually something that I need to implement. Having that discussion, they keep it in mind. They don't have to really develop about it. But there's a way of framing everything in mind, makes them more feature minded. This helps the scalability of the system and future requirements. And there's the second part is because its informal, developers feel easy. So, they can suggest, they feel they can suggest and go, well, so I read an article about design principles. I'm thinking we do this service, or could we try implementing, I saw this recently that they released the newest version of PHP, could we change this system to PHP eight instead of seven point that makes the developer, it doesn't have a direct output on the work, but it makes him invested. And developers that feel invested in the process, even when you're reviewing their work, they aren't antagonized. They don't feel like just working, they feel some sense of ownership. And that sense of ownership and participation and value is what a developer, is the difference between a developer who when it gets to five pm end of the workday, they put off the emails, don't look for me. I'm done. A developer who feels invested, she tells them, we need to do this soon. do you mind giving me an extra four hours. That fast meeting helps them feel part of the project and they're more willing to give that extra effort. It makes them more keen on ensuring quality because they don't feel like it's does some work I have to do. They're more, they feel let me do a good job.\"",
    "code": [
      "Scalability"
    ]
  },
  {
    "participant": "Participant 30",
    "data_chunk": "\"So, what that does is, when you have that first meeting, and it's, in our experience, if only it's successful, well, when that first meeting is a bit more informal, as opposed to having a very formal suit and tie meeting is fast forward, it gives the developer a whole view of the system. Because this fellow will most likely be working on many paths throughout the direction of throughout the duration of the project. So, if they don't, if they have an awareness, what leaving in the works, even as they built, let's say, a service or they implement a database call, they're thinking, well, I better do this in a way, knowing that probably next week, I'll need to do this, or the client wants this. So, as I build this particular feature, as I test the login interface, I have to allow for multiuser login, because I remember the user mentioned in the first meeting, this is what the client wants.  So that's overall understanding of what the system does, it gives the developer a sort of awareness of the long-term direction. When developers work, if you don't involve them in that process, which we've done before, and then you just give them work. This week, do this this week, this week do this. They do good code because you're reviewing it. But we noticed sometimes you have to go back on code. Because you're like, okay, this thing that you built, no, it is good. You haven't, you need to remove this section, because the next part of the system will need this.\"",
    "code": [
      "Collaboration",
      "Understanding of the business requirements"
    ]
  },
  {
    "participant": "Participant 30",
    "data_chunk": "\"Well, you see now for me again, first of all, I thought this is a very valid point. Because what you said is true. And I think there's no, there's no perfect system. So, I think if I was to analyze just the value being my own objective truth, or Scrum is the benefit of Scrum lies in the way it compartmentalizes focus. Yes, you can have a team sharing one roof, they have frequent meals together, they thinking of doing this, they go that, but I find that Scrum in my experience and how it's helped us as a company is you don't have to, I know that's a bit controversial. Yeah, it's controversial because you're telling the developers to not focus on building a wholesome system. But in a way, they're like, you don't really think of every single instance, if an instance comes to mind because you want the workplace to be collaborative, you're able to ask a question, but don't really focus on everything at once. Build your system, if you don't catch something it is okay. Built to the best of your quality in this particular thing. So that when we have the meeting on Friday, and you're able to focus and give it your all, we can now have this situation of all I'm thinking, this can do this, we should have done this, this is a better experience. What Scrum does is, for me now I'll go back to this one point, it isolates the focus point for a developer. Think about this and implement this. Anything else that arises, is handled, is mitigated during the review. As opposed to having a developer think about this and this and this. I also need to think about this and this and this. No. We have a session for working and focusing on technical expertise, because the coding period is a period of technical expertise. Then when we come back to the Scrum meeting, when we are reviewing the code, in that season is when now we can now talk, I'm also thinking you can do this, I'm also thinking you can do this. Focus on your work, do the best you can with what you are aware of. If you feel something, ask, but don't worry, during the code meeting, we will grill you and we will grill each other enough to handle anything. So, that's what I think the biggest benefit of Scrum is.\"",
    "code": [
      "Feedback"
    ]
  },
  {
    "participant": "Participant 30",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 31",
    "data_chunk": "\"\nBut also, this awareness that any, let's say any, it's not that people do errors by mistake, but sometimes we're more diligent than other times. And I think by having this, by improving this feeling of teamwork, you increase people's motivation to be more diligent in the work they do as well, which increases quantity. \n...\nAlso, also, because not yet, not just out of altruism. I mean, of course, if I have a good team, I want to help my team members and so on. But it also goes the other way, if I, if I'm in a team of peers, and I deliver something that has way too many defects compared to the others, it reflects poorly on me in the eyes of my peers. Because I think the powerful thing of this self-governing teams is that you are in the typical sort of, let's call it industrial software development setup. I'm responsible to my manager. And if I screw up, my manager comes to me. That's always the classic way, right, but if you have the self-governance team, and the manifest, just say, build this, and figure out how to do it, then I feel professionally, I have much more skin in the game, because suddenly, it's much more transparent what I'm doing, and it's transparent to my colleagues and teammates as well what I'm doing. So, it gets harder to sort of hide behind and make excuses for bad performance as well, in this case. It quickly becomes more apparent if people in the team aren't pulling their weight, say or if they're doing subpar work. And you can I mean, some people, you can say, okay, you need to improve this. And sometimes you can say, what can I do to help you actually improve on this and see, if you're doing database work, you get more defects than if you're doing front end work. Should we take the tasks off, do you need training, and so on. So, you also have the opportunity to help people because it's, suddenly it's also in my interest that my colleague gets better. Because his performance also reflects on the product that I delivered. So, I think that it goes both ways. And I think it's very powerful, but you're suddenly more, you're not responsible, you're accountable, you're more accountable to your colleagues, rather than to your manager. Because that's the whole technical and reputational thing in it as well.\n\n\"",
    "code": [
      "Accountability",
      "Meeting expectations for quality",
      "Better quality",
      "Transparency",
      "Technical integrity"
    ]
  },
  {
    "participant": "Participant 31",
    "data_chunk": "\"As I've said, it's a combination of these things. It's the short feedback loops and the closeness to the customer to the end user, the availability. And if at the moment I'm doing internal developments, so we're developing an application for internal use. It's easier to get hold of the end user. I've been working other places where we are doing product development, and that means that you're typically talking to a sales type, who is supposed to know what the customer wants, but isn't the actual customer and that's harder. It's because they have to make guesses on behalf of customer feedback. So, it's my experience is that the feedback impact on quality and on features is greater when you have access to the actual customer rather than someone who is simply the actual user, compared to someone who is the just the owner of the product. I think that's, that's very helpful if you can get access to the actual user and get quick feedback, loops, quick feedback cycles. So that definitely helps the product quality, because they also, always find something that you're rarely the main expert in whatever the application is supposed to be doing. If you're working on the same thing over many years, you may become one and get the sense of what the user needs. But typically, you need to have an actual user who has domain knowledge to point out the things you missed, which is also easier to do the sooner you get the feedback. This feedback helps to improve quality, errors are identified sooner then corrected. And then I also think this is interesting. As I said, the motivation and the interaction with your colleagues and teammates is very helpful in keeping quality up because you get this, in the best cases, you get this we're in this together, and you're mutually supportive. And help each other with the code when you need it.\"",
    "code": [
      "Collaboration",
      "Feedback",
      "Software quality"
    ]
  },
  {
    "participant": "Participant 31",
    "data_chunk": "\"I think if you look at its requirements wise, I think the change of focus from the very explicitly specified software into development more by user stories and by less formal methods, where you leave, like you actually think you leave more responsibility to the developers to figure out what needs to be done. I think this in turn forces you to reflect more on what you're doing. And that reflection, in turn, improves the quality of the code you write because you're not just implementing to a recipe, you actually have to sit down and think about what you're doing. To put it a bit on the edge, but I think this increased reflection of not being told what to do. But instead, being told what it needs to be able to do, the software you're writing. It increases your thinking about what you're doing. And that in turn increases the quality of the code you're writing. And then you get this feedback quickly. So, you can actually iterate on the code, which also improves the quality. When you go back and iterate over the same piece of code several times in short span of time frame, I think you tend to pick up more defects, more problems than you would if you wrote the entire thing at once and had the tester or the end user give feedback on the entire thing at the end. Because then it becomes too big. I think this focus on specific stories on functionality, helps narrow down the focus on this specific thing. And by focusing on one thing at a time, you tend to pick out more of the problems with that specific functionality and the quality gets better.\"",
    "code": [
      "Inspection and adaptation",
      "Feedback",
      "Better quality"
    ]
  },
  {
    "participant": "Participant 31",
    "data_chunk": "\"I think maybe by having your focus on stuff like user stories, which isn't Scrum specific, but it's pretty Agile-wide. It also helps focus on specific pieces of functionality, which makes it easier to test rather than if you're doing, I mean, you will still do of course, ad hoc testing where people just click around in your interface and see what breaks but I think the fact that you have described already specific pieces of functionality and what they're supposed to do helps you ensure that all of the different moving parts work. Because it's, it's easy if you get the whole system to test, and you're probably going to miss some sort of workflow and some sort of process through the software that was supposed to work but didn't. So having it broken down by stories, or whatever you call it in your specific setup, is helpful to focus testing and narrowing down. Did we actually get everything, did we get it all implemented? \"",
    "code": [
      "Iterative development",
      "Focus on quality",
      "Modularity of tasks",
      "Better quality"
    ]
  },
  {
    "participant": "Participant 31",
    "data_chunk": "\"So, if you asked me what quality is, I mean, the obvious thing that people think about when they talk about software quality is probably bugs. So, there's something goes wrong computer does something you didn't expect, and so on. That's the obvious, quality mission. But I think in my experience, there's also a more sort of like meta quality, which is the software fit for purpose, does it actually do what it's supposed to do. Is it easy to use, the whole UX user experience thing, can people figure out how to use it? And that's also part of quality. And I think it's especially in those regards, it's not so much in the oh, there's a defect here, we can fix it. That's not an Agile's main strength, in my opinion. The main strength is the ability to get user feedback, and to use that to actually make the software do what it's supposed to do, and to make it function in the way that brings most value to the end user. So, they can say, okay, this is, this is technically correct what you've built, but it doesn't fit our workflow one hundred percent. So could we do these changes, and we'll get a better fit, we'll get less friction in using the system. So, I think that kind of ping pong with the user is very much helping increase quality in the solution in the end.\"",
    "code": [
      "Inspection and adaptation",
      "End users feedback",
      "Better quality"
    ]
  },
  {
    "participant": "Participant 31",
    "data_chunk": "\"Typically, we do code reviews. So, when you're done with a feature, or when you have a prototype for a feature, you do a review. You have one or two others; other team members actually review it before you merge this into the code tree. So, you can have someone catch whatever things you've missed. I think that's the main thing I've used from Scrum is the quality. Also, pair programming can be helpful, but that's I think it's not, it's not so much quality, it's mostly for, it mostly helps developing speed and velocity of a feature development. Because you have, if you have a good pair doing pair programming, you get this sort of ping pong effect, which helps get stuff done quicker. I also think in of course, you will catch something the other guy doesn't. And vice versa, but I think it's not so much the quality, rather the velocity that increases there. I think the main thing, looking at the Scrum stuff that helps improve quality is the code review basically. I mean, there's lots of other stuff I usually do to improve code quality, but that's not Scrum specific. It's stuff like static analysis and lenses and culture, code standards and stuff like that.\"",
    "code": [
      "Code review",
      "Pair programming",
      "Static Analysis Tool",
      "Code standards"
    ]
  },
  {
    "participant": "Participant 31",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 32",
    "data_chunk": "\"I would say the code quality is directly related to like mental health, and things like that. So, there's a lot to be said for sort of dopamine, right? With humans, and like, you see, are you familiar with the rat experiment where they had like a dopamine button for the rat, and the rat kept pressing it, pressing it and pressing it to get the dopamine high? Yeah. Yeah. So, humans are different, but not entirely dissimilar from that. And I think it boils back down to like, the goals and tasks element where it's sort of like, Scrum provides you with that structure of like, here's a ticket, solve the ticket tickets done. And because, you know, you've got that visible achievement sense. Because you know, the ticket goes from to do to done. It's like taking a box on, like your own to do list. And that is satisfying, because it's, it's progress, you can, like, it's measurable, you can go well, actually, I sold 20 tickets this week. Like, yeah, that's pretty good. I'm happy with that. And, you know, it's just sort of like, that breeds the motivation, because then you're sort of like, Oh, well, I can turn this into a bit of a game now, like, Can I do twenty-one tickets this week. Now, there is also the pitfall of getting obsessed with that sort of thing, and then beating yourself up personally for not doing enough tickets. But you know, if you're working in a very positive environment, that's encouraging and supportive, then you don't make it about like, how many tickets you could do, but just sort of like just challenge people to do ever so slightly better and stuff. But we're moving into the realms of like psychology and gamification of work, which honestly, has, has a lot to say basically on, like, code, because code quality literally boils down to, are your developers happy? And are they going to put a lot of effort in because they are happy? And if they're not happy? They're almost certainly not going to put the effort in? You know, that's a lot of a lot of everything just boils down to whether people are happy or not.\"",
    "code": [
      "Iterative development",
      "Focus on quality",
      "Modularity of tasks",
      "Better quality"
    ]
  },
  {
    "participant": "Participant 32",
    "data_chunk": "\"So, I'm working in a good Scrum team. It's very easy to spot bugs. I can think of a lot of cases of this because I used to be like a programming mentor, for a lot of the junior members of my team. And I had like, again, like my open-door policy was just pop me a message if you're stuck. And, you know, one occasion, I had one of my colleagues come to me and say, I'm really struggling with this SQL database stuff. Could you please help me? I said, Sure. Look in a slot for like later in the day with me. And I'll, I'll sit with you for like half an hour to an hour and sort out, they brought me the code. And I took one look at it and just went, Oh, geez, I was like, You are querying your database for everything. And then you are pulling that into the browser. And then you are sorting that with JavaScript in the browser. And they were like, Yeah, and I was like, right. Okay, so number one red flag here. I was like, SQL is faster than JavaScript, it's sorting your data for you. So, I was like, so you don't want to be selecting all of it. You want to be writing your criteria in SQL, and then injecting that to the database. And then there's like, and then all of this code that you're having a problem with here, I was like, it's got, you don't need that anymore. I was like, like, this is I was trying to be very tactful about it. Because, like, it's very, this is more speaking of my employer and their inability to train people. But, you know, like, I was sort of like, No, no, like, this is how you need to do this. And that would have gone into the project. If we hadn't had like that Agile mentoring sort of thing.\"",
    "code": [
      "Collaboration",
      "Knowledge sharing",
      "Software quality"
    ]
  },
  {
    "participant": "Participant 32",
    "data_chunk": "\"So, it gives you the capacity to essentially have no fear of like, repercussion. From your manager, because, again, to draw a comparison, like when I had my good manager in the company, I could say literally anything to him, there would never be a consequence for it, he would recognize that I'm just trying to make the project as good as possible. And I'm trying to help everyone on our team, by all of us improving and growing. However, under the bad manager, I got, you know, I bring him these problems, and I was labeled as negative and complaining. And, you know, that sort of thing. And it's like, the difference here was that my manager viewed us all as equals, in the first case, and in the second case, the manager view disorders subordinates who should do as they're told. And, you know, that is the that is the key difference here is like, when we all felt heard and appreciated, we were driven to improve. Whereas when we felt unheard, and unappreciated, nobody could be bothered to maintain the code quality and things like that you would, you'd have more people just disengaging from work, and sort of like, copy and pasting off of the internet instead of Yeah, we've all been there on Stack Overflow, just grabbing the latest dead. Sea. Yeah, like this is, in my view, why the flat structure is so much better because it just sort of it lets nobody likes to feel like oppressed at work, and nobody likes to feel what I'm heard at work. When we developers feel safe we put extra effort on quality because nobody would tell us why and there are no fear from consequences.\"",
    "code": [
      "Speaking up",
      "Effort on quality",
      "Software quality"
    ]
  },
  {
    "participant": "Participant 32",
    "data_chunk": "\"So, the flat sort of perspective which is talking about like nonhierarchical Yes. That has been one of the most positive working experiences I've ever had in my life. Often, people, like myself, can struggle with hierarchical structures, because often you will encounter that person that has no sort of merit being in the position that they are in. Yeah, this was part of why I left [deleted to preserve anonymity] because, you know, my team was bringing me all these different sort of issues. And I was trying to bring them to managers to get them resolved. that's neither here nor there, though. What is important, though, is that when I was working under one of my managers, we had a strict like, no hierarchy policy between us, I could come to him. And I could bluntly say anything that I had, on my mind, that was a problem. And he would never question whether or not it was like, an actual problem to me. He'd be like, okay, I've heard you, what can we do to fix it? Or like, have you considered it from this angle? And, you know, we would just have like, a completely open and candid conversation about like, maybe like, our tech choices, or perhaps one member of our team was really struggling with learning to code. And, you know, I would come and say, like, person x is having a really terrible time with this, and they can't coach it, you know, we need to do something about that, because they're not getting the support that they need. You know, and while that is quite a blunt way of putting it, he always knew that I wasn't coming to him to be horrible about this person. I was always going like, this person is struggling, that means we're failing as like, individuals, because we're not supporting them. Because, you know, like, if they're not learning that's just reflecting on us, the more senior people in the team. And this is what I sort of mean. So, what was the question again?\"",
    "code": [
      "Psychological safety"
    ]
  },
  {
    "participant": "Participant 32",
    "data_chunk": "\"So, the one that went quite well, we had very like rudimentary testing in place. I'll be completely honest that like, the definition of what was good at that point was very different to what my definition of good is now. I can identify now where we could have done better, because, you know, like, we had decent testing in place. That allowed us to make sure that our code was like producing the correct results, it wasn't throwing errors in all the wrong places and stuff like that. I think we also had more time to develop at that point, because we didn't have to get involved with the customer side of things. This later changed, because of just how things worked out. But, you know, our time was basically spent focusing on making the code, changing the code, fixing the code. I think we mostly, we didn't do very good on architecture, because at that time, we didn't really have the skill set for architecture. Since then, I've really heavily got into architecture for software. And I think, again, Agile ties in really neatly with software architecture, because you know, if you are following the whole, sort of like epics, features, stories and tasks element, you can actually map that whole sort of frame to your architecture. And once you've mapped that, you know, it cross references by like story ID, and like, epic ID and feature ID and things like that. And once you've got that sort of cross referencing, you can, you know, like, let's say your epic is I want to create a shop, right? \"",
    "code": [
      "Software testing"
    ]
  },
  {
    "participant": "Participant 32",
    "data_chunk": "\"So, we used to do pair programming a lot, and code reviews, and retrospectives was something that we didn't really do at that juncture, we've wanted to do them. Because retrospective is one of the most important things like in my, in my view. I think the problem with the retrospective is that there's a right way to do it, and then there's a wrong way to do it. The wrong way to do it is everything went amazing, and were brilliant, and so on and so forth. The right way to do it is, here's what we did good. Here's what we did bad. Let's improve the bad. But I find that there is a, there's a taboo, when it comes to retrospectives around talking about the bad. And you can find yourself under fire quite a lot for being the person that has the courage to talk about the bad. Because unfortunately, people don't like to hear bad things. But one of the key things that I've learned in life is that talking about the bad things helps you grow and improve. That's the whole point of Agile, you can probably see that I apply Agile to like my own life at this point. Like I'm a bit of a nutter when it comes to that.\"",
    "code": [
      "Pair programming",
      "Code review"
    ]
  },
  {
    "participant": "Participant 32",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 33",
    "data_chunk": "\"Because of the continuous feedback from the users, you know, and also encourages things like TDD, you know, because of the iterative approach. And you embrace change. TDD is an essential component of that, you know, if you don't have automated regression tests, it's just a recipe for disaster.\"",
    "code": [
      "Inspection and adaptation",
      "End users feedback",
      "Better quality"
    ]
  },
  {
    "participant": "Participant 33",
    "data_chunk": "\"More bugs? Oh, that's interesting. That's an interesting question. Does it? You know, I think it's great that we discuss ideas and all the rest and yes, yes. You know, if, if something and I'm just thinking about real experience, now I'm thinking through you know, with guys, I'm just so yes. So, we in discussion, right? Guys give the feedback, and we in discussion the guy, okay, maybe, you know, there's a different approach or, or maybe we should look at Redux saga. Sorry, I'm using technical terms, right, versus maybe we should look at technology A rather than B because we using it here or used it before. And that's great. So that discussion, that type of discussion, within the standup would definitely facilitate a platform for discovering more problems within the system or issues. And also, maybe preemptively prevent bugs from incurring or the waste of time, you know, because somebody instead of working on the assumption that this may be the better approach, a fellow team member can recommend a tried and tested approach that he or she may have used in the past. So, I think that type of discussion definitely facilitates the alleviation of more bugs because having two minds, I think is better than, you know having one. And you know, maybe I think they proposed peer programming.\"",
    "code": [
      "Collaboration",
      "Knowledge sharing",
      "Software quality"
    ]
  },
  {
    "participant": "Participant 33",
    "data_chunk": "\"Okay, so, yeah, so as opposed to that Prima Donna approach, the personal commitment, I think, of each individual will want them to produce something better. Obviously, you're taking the approach of having iterations with continuous feedback. You know, it's great, where people can get, or the team members can get feedback on the work that produced. And that's, that's awesome. I'm not even sure from answering the question.\"",
    "code": [
      "Inspection and adaptation",
      "Feedback",
      "Better quality"
    ]
  },
  {
    "participant": "Participant 33",
    "data_chunk": "\"Sure. It's exactly what I was saying about the [Deleted to preserve anonymity] example. Whereas I felt that [Deleted to preserve anonymity], I always come back to her. So, [Deleted to preserve anonymity] is the project manager. So, the project manager always feels as if the burden is on them in order to deliver a quality system, ever. However, what Agile does is takes that responsibility and hands it to the team. Now, because the developers, the testers, the business analysts feel valued, because they know they an instrumental part of delivering this and this, they're not just worker bees. They take a personal responsibility and therefore provide a personal commitment in ensuring that whatever they do is improved quality. At least I'm speaking for myself, but I've seen this overall, within projects over the years. Does that answer your question?\"",
    "code": [
      "Accountability",
      "Commitment to quality",
      "Improved quality"
    ]
  },
  {
    "participant": "Participant 33",
    "data_chunk": "\"Well, I think a Scrum, or TDD lends itself well to the Scrum approach. So, for me as a developer, and now, you know, I'm sort of on the backfoot, because you're really challenging me with these questions. And that's good\n\n…\n\nBecause of the continuous feedback from the users, you know, and also encourages things like TDD, you know, because of the iterative approach. And you embrace change. TDD is an essential component of that, you know, if you don't have automated regression tests, it's just a recipe for disaster.\"",
    "code": [
      "Test-driven development",
      "Regression testing"
    ]
  },
  {
    "participant": "Participant 33",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 34",
    "data_chunk": "\"Okay, another thing I forgot, like, we have this automation suites that runs on a regular basis, where it helps us to check whether the application is stable or not. So, we have these, we have this category as regression test, a smoke test and all. So, it will basically, does the basic functionality check. Like we both have UI and API automation, where the scripts will be running in Jenkins, so the major things are not working every time so like, I think it runs every day, on a scheduled basis. So, it helps us whether it's actually a bug or whether it's actually an intermittent issue. So that's one thing that helps us. \"",
    "code": [
      "Regression testing",
      "Automated tests"
    ]
  },
  {
    "participant": "Participant 34",
    "data_chunk": "\"Well, I can say, technically, technically, I mean, like, we don't follow the perfect Scrum, but still, we follow the set of things that actually has, like what we say, what I can say is, although if you are not having as a daily Scrum regularly, you still have to make your deliverables. It’s you in the end who has to deliver your deliverables. So yes, Scrum helps a lot because there are some cases where in my previous organizations, I used to work with other company teams like I'm from [Deleted to preserve anonymity] and my other colleagues were from [Deleted to preserve anonymity]. That way the communication will be like, a bit tedious, because we cannot sit together, and we can work. So, what we have to do is we have to split the task and we have to, you have to work on that, and who does the thing, obviously, the Scrum Master has to has to decide, like, these are the things that you need to split. And, again, there will be a lead who will be telling us like, how you're going to split it and how you're going to communicate. And there are some even collaboration software's where we can actually like, zoom and like Skype, where we can communicate, and we can test, or we can develop live.\"",
    "code": [
      "Collaboration"
    ]
  },
  {
    "participant": "Participant 34",
    "data_chunk": "\"Well, tools, we generally, like, we have our integrated plugins, like we use different IDs. Like, again, it depends on the companies, like, in the past, I have used Eclipse, and now I'm using IntelliJ. So, we have sometimes we have our integrated plugins, like where, in our company itself, they have developed that. So, what I can say is code coverage. So, there is one plugin that we have, where it will take all the, what is it called, like initial steps, like whether the lines mean, whether the code is not too much. What I can say is.\"",
    "code": [
      "Static Analyser Tools"
    ]
  },
  {
    "participant": "Participant 34",
    "data_chunk": "\"Yes, like when I was there at [deleted to preserve anonymity]. So, I had to like, one time I had to reach another developer who is from another team. So, although he's not on the same floor, he is on a different floor. So just I just had to had to send a chat message on, I think we are using Skype. Yeah. on Skype. So, whether he is available or not. So once as soon as he told he's available, I can straight away Go to him, and I sit beside him. And I asked him like, what is this? And what are the change sets that you had? So, what does this do actually, and it's a piece of code where it actually, an integration part, like I have to integrate an e-commerce plugin to my application so that it communicates both way. So, although it took one hour time for him, for me and him to get into that issue, it solved us, and it helped us solve that. But if that is the thing that was done virtually, I think it will take a day or two because I'm not sure like what he's doing at home, like whether he's there at his workstation or whether he sick, I doesn't even know right. So.\"",
    "code": [
      "Knowledge sharing",
      "Software quality"
    ]
  },
  {
    "participant": "Participant 34",
    "data_chunk": "\"Yes, see, so, I can tell you this, taking an example, like, in the past, like we have this traditional development thing, see, like, where the product was developed completely, and after, like, two months or three months, we will be showing it to customer. And then if the customer likes it, yeah, it's well and good. But if he doesn't like that three months, time is totally wasted. But here at Agile, like we'll be doing in a strange way, like let's say I have developed in some small fraction of code for two weeks, and if the customer really wants to see what the progress is, he will see that and he will give the feedback. If they like that, if the like the idea or they like the development process, he will say, Okay, yeah, I'm good. But if it doesn't, like he will straight away say like, no, it's it should be improved. So here we will be just we can say that. The time we study is only just one string. Instead of wasting the whole three months or six months, we'll be just wasting one or two weeks. But we can get the inputs and we can work on that later. So, this helps us both customer, both from customer perspective and developers time.\"",
    "code": [
      "Inspection and adaptation",
      "Feedback",
      "Frequent testing"
    ]
  },
  {
    "participant": "Participant 34",
    "data_chunk": "\"Yes, technically, because in what, what is the end goal, like we have to satisfy the customer, that's what. So, although there might other there is no bugs, or the purpose is completely fine. I mean, like, the purpose is excellent. But the customer might not be interested in the design, like, he will, he will come with one expectation. But if we give him a product, which doesn't meet his expectations, it's not good, right? So, the sprint, it helps in solving that. Because if not one sprint, we have other sprints like, we can develop our we can get inputs from the customer again, and we can work on that. And based on that, the quality team also does the same. Like we'll be as soon as we get the, we get the inputs from customer, we'll be working on that. And the same way once our code was moved to QA. So, they will be testing it in parallel and they will be providing the feedback. So, it helps us in achieving the product in quicker time and also helping to meet the customer demands.\"",
    "code": [
      "Meets customer' needs"
    ]
  },
  {
    "participant": "Participant 34",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 35",
    "data_chunk": "\"No, I didn't know what's happened. I didn't know she was behind me. So, for this discussion, the Scrum ceremonies, they do not help directly, it's indirect help. So, because we discussed so often in the ceremonies, so they mostly base and we have the one set that is retrospective. So, if we work on our own. Let me think of an example. We had some very obsolete code. We had an obsolete code for reading it was called the rules. These rules would watch for data coming In. And if something happened that match the rule, it would execute some other code. The logic was very complex, extremely complex and it was slow. Our story was to improve the performance, which was a headache. And in this, we had a huge problem, because it was always expanding the scope. Always. Luckily, because of the daily meetings, we could stay a bit easier on top of it. We were multiple people working on it. And each of us had always new tasks, added new problems that arise. And we had the usually fifteen minutes, morning meetings during the day but it could expand into a full hour. And this helped us a lot because we had the set time where you could discuss all these problems and what the entire one day entailed. Why did this help us? Because we could talk as a team to see how we want to handle it. And we would know what future problems it might pose for us. So, we could account for it in time, if we didn't have these meetings, then we will wait for it to become an issue, it would have a much bigger impact on our code as a whole. So even if daily’s do not have a direct impact on the quality, they help a lot in again, seeing repeat offenders and discussing things. You discuss things as they come as they go, because you the daily meetings happen at a very short interval of time, let's say it's eight hours. So, there are a lot of issues that can come together in that amount of time. So, it's a lot easier to see problems that appear. It if anything comes up, you will easily see in the time of the meeting. So, from a quarter of an hour, which everybody said what they did and what they will do, it will extend, I had this issue, he had that issue, we had that issue. And it's easy to identify and resolve. Very easy. And again, all the issues at the end of the run. It's in their account in time that is used for bug fixing and documentation. That's what usually sacrificed, that's the quality I'm referring to, always. And as an extension to testing, quality also, the code might be a little bit worse, because it was not tested properly, and might have bugs that escape. So, it helps a lot with time management and an issue management how we prioritize it, which extends in everything I thought before.\"",
    "code": [
      "Collaboration",
      "Knowledge sharing",
      "Help achieving quality"
    ]
  },
  {
    "participant": "Participant 35",
    "data_chunk": "\"Reviews mostly … Oh, yes, of course. We have gated builds. We have automation, we have for each pull request is built automatically on Azure. And we run integration tests before it's merged into the master branch.\"",
    "code": [
      "Code review",
      "Automated testing",
      "Integration testing"
    ]
  },
  {
    "participant": "Participant 35",
    "data_chunk": "\"So, because we always keep a watch on the bugs. So, and discuss them also, because we were discussing between us, but it wouldn't reach the manager or the PO because the PO also had a say on how we took priority in our tasks. And because our Scrum Master slash manager, it was the same person, he couldn't also prioritize our work. So, because of the daily meetings where we talked about the growing or lowering of the number of bugs, and the retrospectives where we would look at all the, all the sprints in length, and see or observe the issues that came up between us and talk with him also. Because, okay, let's say I had a bug, I saw it, I had an issue. So it was, but I forgot about it, but then another person or two, saw the same thing, but didn't talk about because they saw it only once. We will sit at the retrospective discuss every little issue we had during the sprint levels of observe patterns, we take note of this pattern, feedback the action items, and we'll go to solve them. So, an issue was that we from time to time, we need to for example, we need to instruments, medical instruments, and we had no instruments. We had intermittent bugs, so we just wouldn't observe them until the end. So, when we get that we say okay, so that bug was also in there. So, see saw him so we that's the problem, because it always fails. And we will lose time on it. And it also might hide some other serious issues behind it.\"",
    "code": [
      "Collaboration",
      "Knowledge sharing",
      "Software quality"
    ]
  },
  {
    "participant": "Participant 35",
    "data_chunk": "\"That's a bit hard. Okay. I know a good example. We had our meeting with a PO. It was, not the retrospective. It was a demo. At the end of the sprint. We implemented the feature, how we saw it in the user story and the requirement. We had all the tests we wanted to have, so no bugs there. We had all the documentation. No issue there. We had plenty of time to do it. So, we could say the feature was perfect from our perspective. We had no idea. We had the demo meeting with a PO. We showed her what we did. And she was a bit confused. To say the least. Why does those rules come in that order? Well because that's what we understood from the previous code and from what was written in the story. Well, yes, but there was a BUT. As it turns out, there was a small requirement that you could summarize it in a line of text that was not written there. Which if we didn't have the demo meeting would escape in production. So that's an example of how these demos help and it had a certain naming ceremony.\"",
    "code": [
      "Inspection and adaptation",
      "Feedback",
      "Meet customer's needs"
    ]
  },
  {
    "participant": "Participant 35",
    "data_chunk": "\"Um, so by doing the estimation, for my work, right, that's what you want to ask. It helped me. Okay. Let's see, if somebody else did it for me. He would have to guess how hard that user story would look for me. And, and also guess, how much time I needed to also work the issue completed documentation, write the test. So that's what is needed to complete the work. And that could be a mess. He could overestimate, which would end up in needing too much time and I could do more work. But I wouldn’t take it like, because I could add, I would have to take another user story, but I might not have time to finish it. If we he was underestimated. I have to, I could sacrifice some of the quality of my code to meet the deadline if I couldn't extend it. When I estimate my own work, I always make sure I have time for quality.\"",
    "code": [
      "Accountability",
      "Commitment to quality",
      "Software quality"
    ]
  },
  {
    "participant": "Participant 35",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 36",
    "data_chunk": "\"I wouldn't say quality assurance is really Scrum related. We have been doing quality assurance for years before Scrum. For example, in my industry, Health care, you have testing, pros testing, [inaudible] testing, automated testing. So really about code coverage and testing. That is the first step or line of defense expected and provided results. And really when it comes to testing, it's the fact that when you test and retest the same thing over and over again, you start to neglect steps in the testing. So, unless you have automated testing, errors might pop up in the testing steps. And these skip steps, might lead to bad code quality. Really the code quality depends on the quality on the testing. And a lot of projects try to save resources on reducing testing. They usually say the developer will handle everything from planning, implementation, testing, building, launching and releasing everything. One man team army, which is very bad. It comes back to Agile when human resources are allocated to require the lack of resources, and then I read this is very bad from my perspective, because you cannot in this industry do everything. Very simple areas require your multiple years of experience, and you cannot keep in your head, database testing, implementation, environments. Impossible. Whoever expects you this has no experience in project planning. The project is probably going to fail. A large project or if it’s a small project, it's probably can be rewritten multiple times. Code quality, also Scrum. So having multiple types of teams in Scrum helps you with the testing. We do have multiple teams, like a team that focuses on people actually look at you, your mental state, try to help you improve your mental state. The actual implementation team, the tester team, the team managers, so it's a much clear separation between roles. I think Scrum helps in this regard the code quality because it helps you focus on your specific code in large projects. In small projects, another story.\"",
    "code": [
      "Software testing",
      "Automated testing"
    ]
  },
  {
    "participant": "Participant 36",
    "data_chunk": "\"Yeah, sure. My positive experience, is collaboration. It makes people work together.\"",
    "code": [
      "Collaboration"
    ]
  },
  {
    "participant": "Participant 36",
    "data_chunk": "\"Yes, I think the code quantity increases. We discussed, we discuss certain tasks so many times that you review it, and many, many times you realize, oh, maybe it's not the perfect code. Maybe I could do it better and you have the time to rewrite it. So, I think the productivity and the quality itself increases.\"",
    "code": [
      "Knowledge sharing",
      "Increased quality"
    ]
  },
  {
    "participant": "Participant 36",
    "data_chunk": "\"Yes, it does [Scrum motivate me to write better code]. Personal pride for the retrospective and you present your results. And we are actually quite proud of your code, checks all the boxes. It's beautiful. It runs, it provides results. Because it was a simple task, you have a high chance of success to check all these checkboxes. You estimated enough time to perform all the required steps for the formatting, the commenting, the testing, the rechecking, and you actually are proud of your code. And that brings value your personal value, increases your morale, which helps you actually evolve and do better and better code all the time.\"",
    "code": [
      "Accountability",
      "Technical integrity",
      "Better code"
    ]
  },
  {
    "participant": "Participant 36",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 37",
    "data_chunk": "\"I think it's good from a perspective that people struggling with problems around how to deliver what they're trying to deliver. It can get very fast solutions for other people who know how to do things, or I've done it before, or can help them navigate their way away from issues. It can help the testing get obviously better insight into what's happening and have a daily interaction with everybody in terms of what they're seeing versus what the developers are seeing versus what the PO seen as the Sprint's evolve. And as the developments come out, it doesn't let anybody hide, you know what I mean? So, Waterfall lets people hide very easily. I can hide for weeks, without people knowing what's going on. Whereas Agile and the sort of daily meetings as long as it's in good spirit. And people understand it's in good, good, all good intentions. Yeah. It enables everybody to sort of open up the journey a bit and say, you know, this is what I'm seeing. You know, we better fix it.\"",
    "code": [
      "Transparency",
      "Feedback",
      "Better quality"
    ]
  },
  {
    "participant": "Participant 37",
    "data_chunk": "\"It's great to have developers sitting there and inside their own little bubble, developing code. If you're not able to talk to peers and get ideas on how to structure your code, and how best to solve problems, one, you can end up developing the wrong thing. You can end up writing code that while it might achieve a goal, it might be totally unmaintainable going forward. You might end up writing very inefficient procedures or stored procedures that are just ridiculous. You might end up spending days on a problem that your teammates could help you solve in an hour. You might, for example, in talking with the team, especially the testers, they might help you pinpoint places in code that you haven't paid attention to. And they need to pay attention to. And even when you're talking about your own development and the sort of thing you're trying to develop. Sorry, I just had to close that. Even when you're talking about your developments in your stand ups, the testing team can also think of other ideas, the things they need to be testing. So, they're not in a bubble, either. I mean, there's all sorts of benefits to collaboration ... Or you definitely become better at writing code. You also become better at helping others write code, and helping, sort of helping the team work better together.\"",
    "code": [
      "Collaboration",
      "Knowledge sharing",
      "Better code"
    ]
  },
  {
    "participant": "Participant 37",
    "data_chunk": "\"So, we did very regular peer reviews. With every time you're, you were trying to push anything through to the Done stage, you'd have to go through the pull requests inside. From memory, we were using Microsoft DevOps to do that. And all of our team were very good at peer reviewing code, which was good. We had; we didn't have any regimented code standards in place in terms of automated checking. But we definitely had well understood practices around how the existing code was in conformity to that. So that was one part of it. So, we were talking specifically about code?\"",
    "code": [
      "Code review"
    ]
  },
  {
    "participant": "Participant 37",
    "data_chunk": "\"Yeah, I suppose, simply put is if you are able to identify issues whether from a client facing perspective, they helping you identify problems in your software. And even internally, being able to identify problems and raise them in the issue tracking cycle of things, in the issue planning cycle and things. You can obviously continually improve quality. It's one of the problems that we had early on with a job was that the product owner was sort of planning everything and everything everybody else was sort of subservient to what the product owner had planned without being able to appraise issues as they found them. So, for example, a developer would be working through cash flow calculations or accounting calculations for some particular loan or bond structure and working out effective rates or something like that. And they would find that find a bug in the current version was causing ridiculous results. Because that wasn't on the current trajectory of planning by the PO, they couldn't actually raise it. Nobody would listen to them. So, they just had to sit there knowing there's a bug. And it was at the point where the unit tests were being developed to confirm the bug was correct. Even though rather than trying to fix the bug and write proper unit test to ensure the system work, they'd be writing unit tests, knowing the bug was there and having to pass an incorrect unit test. And that's what ends up happening in that process. To being able to easily raise issues as you find them and get them into the development cycle, as well as clients finding issues and telling you about them, it helps makes the whole system a lot better, very fast. But again, it's breaking down that barrier, and allowing the team to be fluid. Not having these gateways of you know, you can't, because the PO manages that, or you're not allowed to talk to him about this. Yeah. Those sort of issues.\"",
    "code": [
      "Inspection and adaptation",
      "Identifying bugs",
      "Meet customer's needs"
    ]
  },
  {
    "participant": "Participant 37",
    "data_chunk": "\"Yeah, that's a good question. Definitely. In every instance I've come across, it definitely motivates us to do better for your team. Because you're working interactively, every single day talking, collaborating, discussing what's going on, confronting issues, challenging other people's conceptions, and practices. So, it's a continual challenge to improve yourself. So again, I think the Agile approach of you know, there is no \"I\" in Agile, it's a team thing in terms of responsibility and accountability. I think that's goes a long way to enforcing that, I suppose.\"",
    "code": [
      "Accountability",
      "Commitment to quality",
      "Better code"
    ]
  },
  {
    "participant": "Participant 37",
    "data_chunk": "\"Yes, we have, obviously, manual testing for features. Yeah, so any development going through their feature branches would have manual functional testing, at the UX level. They also had API level testing, using Cucumber and most of the tools hitting our API's, as well as automated testing of the actual UX side of things. So, there were quite a lot, quite a lot of automated testing going on, as well as the functional testing. So, the sort of the running plan of every single sprint, was the tester would be doing the functional testing of each of the feature branches. Then, when the code was peer reviewed, and ended up into the main code base, they'd be doing another functional integration testing that code with the rest of the system. Then they'll be updating the all the automation scripts to cover the functional testing they just done. And then by ensuring that was then put in into the mark, as your DevOps, to make sure that it actually it was automated every single time a build was done. As well as all the API scripts, which were predominantly just run by the testing team as a whole on a release basis, as well as the sort of automatic UX test. It was more of the gateway check.\"",
    "code": [
      "Software testing",
      "Automated testing",
      "Integration testing"
    ]
  },
  {
    "participant": "Participant 37",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 38",
    "data_chunk": "\"Actually, when you work on some project, if it's a Waterfall project, you just do your work, pass it to further steps in the process to test or somewhere and you will too for example, another project, so you feel your work is finished. But when you work in iterative approach, you know that in next sprint, you will return to this code, you will need to change it and you will try, you're trying to do your code better, better quality.\"",
    "code": [
      "Iterative development",
      "Motivation for quality"
    ]
  },
  {
    "participant": "Participant 38",
    "data_chunk": "\"For example, you asking to do some feature. And you know that this, you need to write the codes that can be used in a similar feature in this project later. You have two choices. Make quick changes that solve this immediate problem and build this feature or build more better code that helps you to build a similar feature in future. And you know that next week might or maybe next sprint, you'll get tasked to build this similar feature, and you'll return to this problem again. So, you do not solve this immediate problem, but you solve both the general problem for future sprints.\"",
    "code": [
      "Better code"
    ]
  },
  {
    "participant": "Participant 38",
    "data_chunk": "\"For me, particularly, inside software, when a sprint is planned, we have sprint backlog with a task. And every developer can select a task to do. So, there is no direct assigning tasks to developers by some manager or team, everybody decide what he'll do and which task to do. For me, I know this, that I do know this area better, but he knows this area not good. And I do such task better than others. So, I can select tasks that I can do more effectively.\"",
    "code": [
      "Accountability",
      "Motivation for quality",
      "Better code"
    ]
  },
  {
    "participant": "Participant 38",
    "data_chunk": "\"It's iterative and because customer expectations are changing. First of all, the customer can see what you do after each sprint so it's not a Waterfall when customer will see the product actually after the project is finished or maybe after some milestone but still milestone it's a big chunk of time. So, customers will see almost immediately what team do, and can adjust his expectation and feel that quality of what he get is, what is, what he wants. I'll explain because when I worked in [inaudible] we don't use Scrum, not don't but yeah, we don't actually. And when we show what we do to my client, and he tried to do it. He said nothing is working. But maybe not correct, but it’s not working. It's his usual phrase. So that means that we might maybe buy the software, first impressions that quality is awful. But after that, when we try to understand what he mean, we understand that he don't know which functionalities, he doesn't know which functionality we implemented and try. And he, he has his own expectation. And we have software, which might be solve his problems, but in different ways. So constant interaction with customer is very important. Scrum does this.\"",
    "code": [
      "Collaboration",
      "Inspection & Adaptation",
      "Feedback",
      "Meet customer's needs"
    ]
  },
  {
    "participant": "Participant 38",
    "data_chunk": "\"There is another side of interaction with a client. It's called sprints, it's during the sprint the team is isolated from new tasks from the client. Because in usual will work when you work on some big task for example, client tries to interrupt you as he thinks of a more urgent task or maybe some bugs and this interruptions will not let you write this task with a good quality. So, you might be switching to another tasks might lead to bugs. And not good performance, I think. So, when you have well defined sprints, you work on this task only, and that's helps you to concentrate and try good quality software.\"",
    "code": [
      "Iterative development",
      "Focus on quality",
      "Modularity of tasks",
      "Good software qulaity"
    ]
  },
  {
    "participant": "Participant 38",
    "data_chunk": "\"Usual methods in software development, testing. So, we have a guy in the team and as soon as we implement some features, we pass it to review to test. At the end of the sprint, all features developed inside the sprint should be tested.\"",
    "code": [
      "Functional testing"
    ]
  },
  {
    "participant": "Participant 38",
    "data_chunk": "\"Yeah, yeah. We use code review.\"",
    "code": [
      "Code review"
    ]
  },
  {
    "participant": "Participant 38",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 39",
    "data_chunk": "\"No. QA testing is done in the testing environment. And we promote our code from dev environment to test environment, then QA testing happens. Once all the issues are fixed and QA clears it from the queue, then the product owner will go for the UAT deployment and then the product owner communicates with the end user or the business team. So, for testing of the application...\n\nCode quality and for good qualities like we follow a standard code quality practice among our team. So, there are certain approaches. And we follow the code review practice also and it is the peer review like anyone on our team reviews the code before committing to the source code or the repository. So that into the code quality and there are also use this static code analysis tools in our ID basically currently we're using this Eclipse and IntelliJ. So, these are more of a technical perspective. \n\"",
    "code": [
      "Software testing",
      "Code review",
      "Coding standards",
      "Static Analyzer Tools"
    ]
  },
  {
    "participant": "Participant 39",
    "data_chunk": "\"Once our software is ready, and we will deploy it on. First, we follow separate enrollments for testing then UAT is prior to the production. So, once we'll deploy our software to the UAT then we provided for us the third party and user to test our service or our application.\"",
    "code": [
      "User acceptance testing"
    ]
  },
  {
    "participant": "Participant 39",
    "data_chunk": "\"So, these like it's not like something Scrum. Scrum is just like a process like waterfall. Or better in the sense like since we have better process to code. And do we have multiple Scrum teams for the same product. It means at the end; the code quality will be better if you compare it with the preferred model where the team size is very large. And it's quite, not quite, but it may be a bit challenging to ensure the code quality within a large number of team. So, if we consider Scrum, we have a small number of teams and our development scope is as a part of our product as a means it will consider product as a whole, then we are involved in maybe few modules. One thing is, we'll deliver maybe a couple of modules, three, four modules, if it has several modules, so it's better to maintain. We can better maintain the source code quality, if our source code itself, the number of lines is less or the number of classes we write is less. So, in that way, it is manageable like this. In our Scrum team, we will ensure more code quality as compared to a larger team.\"",
    "code": [
      "Iterative development",
      "Control over quality",
      "Modularity of tasks",
      "Code quality"
    ]
  },
  {
    "participant": "Participant 39",
    "data_chunk": "\"Yes, so, since we follow the daily Scrum meeting, so everyone is involved in that Scrum team from product owner and business analyst and development team or testing team. If anyone needs talk at any point of time, so I think we already discussed this one. So, it's like, if within our team, there won't be any blockers, if there is any blocker then we need to resolve them at the very beginning. So, it means everyone expects to involve or to clear that blocker as soon as possible. So, it will speed up our development effort since everyone is involved in, it's not like a single person's task. So, your other team so, from the requirement perspective, if we have any kind of doubt, then the business analyst and the product owner they will clear our doubts. The other thing is if there is any changes in the requirement during our development, then the product owner will inform it through our business analyst. So, we can make changes in our requirement. So that once our product will be delivered or at a later stage of time will not get the requirement again and we need to do the rework. So, that is the benefit, it also at the end it also adds to the quality of the product quality in that sense, it is as per the expectation of the end user of the business team. So that is the benefit we get out of here.\"",
    "code": [
      "Collaboration",
      "Understanding the requirements",
      "Meet customer's needs"
    ]
  },
  {
    "participant": "Participant 39",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 4",
    "data_chunk": "\"Good question! They become intimately knowledgeable of the business requirements and the expectations. This helps testing the real users’ expectations rather than making assumptions. This knowledge helps identifying and reducing bugs.\"",
    "code": [
      "knowledge of business requirements",
      "Fewer bugs"
    ]
  },
  {
    "participant": "Participant 4",
    "data_chunk": "\"Now the software quality assurance starts from the day one. From when the project starts, it's not like you do all the development and then you go to testing. So, the first part is like I said, the clarity in the requirements that's the first part. So, you are making sure that acceptance criteria is clearly defined. Before it even comes into the sprint backlog, before the team takes it. It's when it's really defined. And coming to the next part now, you have the acceptance criteria the team starts with writing acceptance tests. So that's one part that they are expected to do. We follow BDD which is again extreme programming practice. But it doesn't stop you from implementing in a Scrum environment as well. So, the team typically does acceptance criteria first. Even at the point where the story's entered into Jira.\"",
    "code": [
      "Acceptance criteria"
    ]
  },
  {
    "participant": "Participant 4",
    "data_chunk": "\"Once the acceptance criteria is written since like I said that when you've done the internal, the PO is involved in terms of writing the sprint's goal & acceptance criteria as well. I mean just like it's clearly structured so that when the team writes the acceptance tests, they are very clear how to write it. So, the team starts writing the acceptance tests again, I see little bit of deviations for some teams. Initially they will start by writing the code and then write the acceptance test. But the ideal scenario we start by writing the acceptance test and the unit test and then more of a test-driven development so that ensures the quality. The unit tests ensure minor aspects are not missed out. We had maybe like five environments because the team develops on the dev environment, they deploy on the QA environment. So, during the course of the Sprint once you deploy into QA, you are doing a continuous integration.\"",
    "code": [
      "Acceptance Testing",
      "Unit testing",
      "Continuous integration"
    ]
  },
  {
    "participant": "Participant 4",
    "data_chunk": "\"They come into picture from day one. They don't come into picture only at testing time QA are also functional experts and they are not just purely testing guys, like maybe earlier times. Let me just touch on the part of the QA first, QAs come from the point there is a shaping, when the product owner is evaluating a requirement QA is involved because he will help refine the acceptance criteria. He is  expected to bring out scenarios which might not be thought through by the product owner. So that's where my product owner leverages the QA role. So that's the first place where QA gets in, so he starts even prior to the development team according to me because of the value he brings in at that stage itself.\"",
    "code": [
      "Early engagement of QA"
    ]
  },
  {
    "participant": "Participant 4",
    "data_chunk": "\"You are ensuring to make sure the quality is being met. You are ensuring the acceptance tests are passed. That's a prerequisite to kind of move to QA. And so, and then once all the tests are passed, it is automatically pushed to the QA environment. And again, they're like I said, we use assure DevOps so on the CI aspects making sure the code compiles. QA will have already written the integration test. I mean as the team was developing. Again, I mean we can see the role of the testing is different now. Now, you use more of a test engineer, he'll be kind of doing the automated testing. Basically, the integration test, and feature level test, he would have been planning for that. That would be written. The integration test would be run on the QA environment.\"",
    "code": [
      "Integration testing",
      "Automated testing"
    ]
  },
  {
    "participant": "Participant 4",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 5",
    "data_chunk": "\"It changes behavior which helps better quality. When developers are empowered, they make their own decisions on the quality of their work. They do not need to check with their manager to write better code or ensure an optimal design. They have more control over their work and they become committed to meeting the expectation on quality. The key here is you empower everybody to make decisions on the quality of their work. I experienced when deployed properly this should result in heightened productivity and a better quality of the software.\"",
    "code": [
      "Empowerment",
      "Commitment to quality"
    ]
  },
  {
    "participant": "Participant 5",
    "data_chunk": "\"One of the qualities of Scrum is that it enhances the collaborative aspect of the software development. The team collaborate more and knowledge flow better among the team’s members. This knowledge can about users’ requirements or simply how to resolve a bug or write better code. Developers invest on quality when they feel it is safe to do so. For example, if you blame them for not meeting the deadlines and you don’t give them enough time to work on the quality to start with, then they will compromise quality to meet the schedule and avoid the blame. I’ve seen it happening; developers become disengaged and uninterested; then they produce crappy code.\"",
    "code": [
      "Collaboration",
      "knowledge sharing",
      "Psychological safety",
      "Investing on quality"
    ]
  },
  {
    "participant": "Participant 5",
    "data_chunk": "\"People write code! People test software! When they feel accountable, they take ownership of the work they do and its quality. I experienced as a team lead, when a developer is accountable, he will always take responsibility for the outcome of his work. In the business of developing software this means quality code, meeting the business needs and less defects.\"",
    "code": [
      "Taking ownership for quality"
    ]
  },
  {
    "participant": "Participant 5",
    "data_chunk": "\"The framework touches on accountability and having software developers responsible for end to end, from creation to deployment but then I would say accountability is more a cultural point than a metric in Scrum.\"",
    "code": [
      "Accountability"
    ]
  },
  {
    "participant": "Participant 5",
    "data_chunk": "\"When you are working in a Scrum or agile environment, your developer has skin in the game. They need to reduce the amount of bugs that they might have, the amount of miscellaneous errors or higher structural and architectural errors. These are what I believe try to increase quality in the Agile environment. For that reason, but it’s not definitely guaranteed higher quality. The culture and experience and the people that work in that environment, work in that framework and needs to increase the quality and the speed. In the ideal world, Scrum would help to increase quality.\"",
    "code": [
      "Better quality"
    ]
  },
  {
    "participant": "Participant 5",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 6",
    "data_chunk": "\"I think the most important think about Scrum is it brings people to collaborate better. I used the example of Sprint planning. During this meeting, the client, the developers and the QAs discuss and align their understanding of the requirements and expectations on quality. This significantly reduce bugs; developers know what to develop. They do not make assumptions and the QAs know what to test. Here you have it; a product with less bugs, that’s quality.\"",
    "code": [
      "Collaboration",
      "Understanding the requirement",
      "Fewer bugs"
    ]
  },
  {
    "participant": "Participant 6",
    "data_chunk": "\"If it's a story as simple as I just want to login to the system, the test case it will be the email address has to be valid. The password has to be at least these characters, it should not except this kind of password for example. This should happen when I enter the wrong password or stuff like that. And so those test scripts are put in place. Now in terms of the structural dynamics, when the developers coding the story, it's on their local machines. But before the story is handed off to QA, it has to be deployed to an environment that we call in a SIT environment. That is the first stage of deployment and that's where the QA resources are expected to test the features on and then there is defects whatever comes up in that environment. When the SIT is complete for that, and we hand over the feature to for the client to verify our tests on their side. So, testing comes from their side. There's a different environment. That is the UAT environment.\"",
    "code": [
      "System testing",
      "User acceptance testing"
    ]
  },
  {
    "participant": "Participant 6",
    "data_chunk": "\"So, I think from two or three dimensions. One is QA being involved in the sprint planning. So, their questions and answers, we refine those requirements in a way that that they are clear enough for the developer to start but also make sure that every requirement gets into the quality assurance. Our QA makes sure that the requirements are stated crystal clear enough for the dev team to understand so that it reduces the risk of ambiguity and more defects. Then with the sprint, after these requirements are satisfied, the QA is expected to write test scripts which is they will go through the stories and they will create test scenarios and they will create those test scripts one by one for each story depending on the weight of the story. Some stories will have four or five test cases while the other my may have fifteen to twenty test cases.\"",
    "code": [
      "Test cases"
    ]
  },
  {
    "participant": "Participant 6",
    "data_chunk": "\"So, there's automated regression out there and also in an ideal world, the developer is expected to write unit tests, which in both project does not happen very well. And that's where the maturity factor comes in as we discussed in the beginning. So, the unit tests are expected to be there but they're not there as mature as it should be. I think that's pretty much the entire landscape for both of these projects.\"",
    "code": [
      "Unit testing",
      "Regression testing"
    ]
  },
  {
    "participant": "Participant 6",
    "data_chunk": "\"Yes. That's exactly right. I agree to what you said. It does bring a dynamic or a better perspective and to me, it's very positively correlated. Sorry for using research terms. I shouldn't say this without evidence or data, but as I see it, there's a very strong correlation between engaging QA resources early and the outcomes of the delivery. So, it does help because when the two resources involved in planning from the very beginning. They have to challenge the scope. A lot of times and when I say a lot of times, I think it's more than eighty percent of the instances, where the QA have challenged the scope in a way where the scope had to change, and they had to adjust it. So that means that you kind of detected the fault very early before that happened, and therefore lowering down your cost of quality, and therefore improving the quality of the product ... So yes, it does. It does help in bringing that and when you do the test planning earlier when a developer is kind of working on the user story and he does see a test script ready with it. And then he's coding it, he knows what he needs to prevent. So, the test plan is right there and therefore it also kind of impacts the end and outcomes. So yeah, I think I think I would agree with your notion that it does impact and it does bring about a change in contrast to the traditional practices. \"",
    "code": [
      "Early engagement of QA"
    ]
  },
  {
    "participant": "Participant 6",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 7",
    "data_chunk": "\"So that's important. Another thing is with some practices, I apply actually some of those. I require my teams to apply some of those like the peer programming. So, this way, people learn from each other. So, when I had a senior programmer, I assigned a junior one to that programmer and they learned from each other. And this is actually part of like the continuous improvement and learning. Developers learn from each other’s how to write better code. So, this improves the quality of the software by applying those techniques there and learning from each other’s. Another one is let's say we apply these...actually we are using GitHub. And with the practice of GitHub, when we assigned a task to a developer, we request him after he's done programming and write the unit test for the work he has done. He sends a Pull Request. And another team member, and most of the time it's the project leader or a more senior one, reviews the code and provide feedback; developers learn from it. It's not just the unit test that's running. He reviews the code. And if it's correct, then he approves it. And this allows that feature to be included in the software. And the person who is responsible for the quality, the quality assurance engineer or tester actually tests and provides feedback.\"",
    "code": [
      "Peer to peer learning",
      "Knowledge sharing",
      "Improved quality"
    ]
  },
  {
    "participant": "Participant 7",
    "data_chunk": "\"Yes, because the thing is, like things are changing fast. So, what happens is like on the background, we try to make it simpler for the developer. The developer only is concerned about the tasks assigned to him. And when he's done, he sends a pull request. After he sends the pull requests, he's done. The next step is the responsibility of the project manager. He reviews the code. And if there is a problem, actually, he sends it back. So, what happens is we are following, let's say, instead of publishing, whatever the developer has done, we have a check mechanism. So, it's a quality assurance that's done during development. The code review is actually quality assurance that we're doing there.\"",
    "code": [
      "Code review"
    ]
  },
  {
    "participant": "Participant 7",
    "data_chunk": "\"Yes, mainly Scrum. Ok, let me start with collaboration. Now if the development team worked as one team, not like individuals, because what I have experienced actually doing my roles in the industry, is like sometimes people actually argue. They actually blame the other one because of those tasks. But with agile development process because you need to have regular meetings and within those meetings you discuss what kind of problems you have. And this actually allows the other team to contribute to help you. So, you can collaborate. And it's not just one person owning the task or the feature, the team owns it. You cannot have someone to blame. It's either you blame the whole team or there's something wrong with the features.\"",
    "code": [
      "Collaboration"
    ]
  },
  {
    "participant": "Participant 7",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 8",
    "data_chunk": "\"So, involving QA at the beginning and just hearing their side of the story of how much they need, how much effort they need to finish a particular task or their valuable feedback that you can get from them as to what can go wrong. What can complicate things during the way, then this really serves for somebody who is planning the development, product owners and developers in the end. And to have in mind what can go wrong and pay attention to things and to be aware that they need to finish something and leave time for a person from QA to finish their work. Because if not, the whole thing is going to be a problem because they're one team, you know, QA is part of one dev team. And I think this really empowers this collaboration and enhances this teamwork.\"",
    "code": [
      "Early engagement of QA"
    ]
  },
  {
    "participant": "Participant 8",
    "data_chunk": "\"They [QAs] become intimate with the requirements. This allow them to efficiently test the software. Not only knowing what to test but they make less assumptions about the requirements, which also means less bugs and faster delivery.\"",
    "code": [
      "knowledge of business requirements",
      "Fewer bugs"
    ]
  },
  {
    "participant": "Participant 8",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  },
  {
    "participant": "Participant 9",
    "data_chunk": "\"But the QA comes and gets involved directly with the product owner and not just the development team. Because they are the ones who understands the product owner is someone who is a technically functional person. The collaboration with the product owner helps better understanding of the requirements and expectations and hopefully more efficient testing and less bugs.\"",
    "code": [
      "Collaboration",
      "Understanding the requirements",
      "Fewer bugs"
    ]
  },
  {
    "participant": "Participant 9",
    "data_chunk": "\"From my experience, when the environment is transparent, the quality of each one on the team is subject to scrutiny and review, nothing is hidden. Developers give feedback to each other, QAs test and provide review, etc.\"",
    "code": [
      "Quality review"
    ]
  },
  {
    "participant": "Participant 9",
    "data_chunk": "\"Now, another aspect of it is this has to be vetted by the third parties. So how we used to do it is we used to have these audits from different teams. So, once we had to deliver a project after opening the sprint, we have this audit committee, which is going to go and check from the development perspective that the code is of quality or not. So, it's really from the business perspective if all the requirements have been drafted in a proper format or BRDs or not. Similarly, we have these audits in place, which helps us finding the gaps and improving it from next set of deliveries. So, the third party, the teams which are not actually having any stake in your product were the ones who used to audit it. That makes it more stringent and better for the company.\"",
    "code": [
      "Peer review"
    ]
  },
  {
    "participant": "Participant 9",
    "data_chunk": "\"So, the best benefit is saving on the timelines. So, for example, let's say in a sprint of two weeks, you have created three days of QA before the release. Now, let's say there are too many bugs that are coming up that you have not planned initially. So, if QA comes late, the chances that a lot more bugs would have come in. So, the more number of bugs that have come in, the higher the chances it will take more amount of time to fix them, which makes it difficult for the timelines to be met for the delivery. And it impacts the overall lifecycle. So, the good thing is, if you involve QA early you can predict a lot of things that needs to be tested. So, the pressure on the QA team gets reduced from getting involved at the end to being involved in the overall lifecycle is that they can focus more on the other side and functional requirements at the end rather than just focusing on the bugs.\"",
    "code": [
      "Early engagement of QA"
    ]
  },
  {
    "participant": "Participant 9",
    "data_chunk": "\"Sure. So, what we used to do is we used to have these audits. So how we used to do it, for example, let's take tracks. So, the product order of one track. So, every track has different teams where you have an engineering team, there's a product team, so now the scrum master has certain guidelines they're supposed to follow for every project. So, whenever a sprint gets completed for example, there's a project plan need to be created by a scrum master. Then stand-ups need to be conducted. So, all these things, which are in the guidelines of any project to be completed, you have different teams who go back and check that. So, is there sufficient documentation or not? If there's sufficient documentation, are the guidelines being followed or not? If the guidelines are being followed, to what extent have they been followed or not? Similarly, when it comes to product, the product owner has to create the product requirement document. Are all the flaws supposed to be covered - are they covered in the BRD or not?  What kind of issues that came in during the time of testing of that product?\"",
    "code": [
      "Documentation",
      "Adherence to standards"
    ]
  },
  {
    "participant": "Participant 9",
    "data_chunk": "\"Sure. there are different teams that work. You have a squad where you have where you have a scrum master and you have a development team. So, these are the three major stakeholders that happen except the business. So, what do you do is every track needs to define the quality parameters? So, when it comes to Agile, it's like mutual responsibility of everybody to showcase quality. Quality in terms of planning, quality in terms of delivery, quality in terms of testing and quality in terms of the overall outcome of the project that you have anticipated when you created a business requirement document. So, every team defines those quality parameters initially. That's one thing. OK. Second thing is when you create those audits for these things, for example, then the development team is writing the code, it needs to have comments in it. That's basic hygiene for a development team. So, are they writing quality code or not, which can be understood by someone else. Is that a sufficient amount of unit testing that's being done by the development team or not? From the product code perspective, how do you prepare the user acceptance test cases, which can be used the QA team. Are most of the scenarios or cases covered and they have been explained?\"",
    "code": [
      "Code review",
      "Code readability",
      "Unit testing",
      "User acceptance testing"
    ]
  },
  {
    "participant": "Participant 9",
    "data_chunk": "\"Well, if the project is transparent, it's bound to be more successful than the ones which are not. Because transparency leads to openness, transparency leads to more questions. More questions lead to more answers, and more answers leads to less bugs and better quality. So, the better the clarity that they have, it will reflect on the product.\"",
    "code": [
      "Transparency",
      "Fewer bugs"
    ]
  },
  {
    "participant": "Participant 9",
    "data_chunk": "Data chunk",
    "code": [
      "Code"
    ]
  }
]